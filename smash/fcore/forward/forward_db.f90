!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - Opr_StatesDT
!%
!%          ========================== =====================================
!%          `Variables`                Description
!%          ========================== =====================================
!%          ``keys``                   Operator states keys
!%          ``values``                 Operator states values
!%
!ยง      Subroutine
!%      ----------
!%
!%      - Opr_StatesDT_initialise
!%      - Opr_StatesDT_copy
MODULE MWD_OPR_STATES_DIFF
!% only: sp, lchar
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
!$F90W char-array
  TYPE OPR_STATESDT
      CHARACTER(len=lchar), DIMENSION(:), ALLOCATABLE :: keys
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: values
  END TYPE OPR_STATESDT
  TYPE OPR_STATESDT_DIFF
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: values
  END TYPE OPR_STATESDT_DIFF

CONTAINS
  SUBROUTINE OPR_STATESDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(OPR_STATESDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this%keys(setup%nos))
    this%keys = '...'
    ALLOCATE(this%values(mesh%nrow, mesh%ncol, setup%nos))
    this%values = -99._sp
  END SUBROUTINE OPR_STATESDT_INITIALISE

  SUBROUTINE OPR_STATESDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(OPR_STATESDT), INTENT(IN) :: this
    TYPE(OPR_STATESDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE OPR_STATESDT_COPY

END MODULE MWD_OPR_STATES_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - OutputDT
!%
!%          ======================== =======================================
!%          `Variables`              Description
!%          ======================== =======================================
!%          ``cost``                 Value of cost function
!%          ``sim_response``         ResponseDT
!%          ``opr_final_states``     Opr_StatesDT
!%          ======================== =======================================
!%
!%      Subroutine
!%      ----------
!%
!%      - OutputDT_initialise
!%      - OutputDT_copy
MODULE MWD_OUTPUT_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: ResponseDT, ResponseDT_initialise
  USE MWD_RESPONSE
!% only: Opr_StatesDT, Opr_StatesDT_initialise
  USE MWD_OPR_STATES_DIFF
  IMPLICIT NONE
  TYPE OUTPUTDT
      TYPE(RESPONSEDT) :: sim_response
      TYPE(OPR_STATESDT) :: opr_final_states
      REAL(sp) :: cost
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF
      TYPE(RESPONSEDT) :: sim_response
      REAL(sp) :: cost
  END TYPE OUTPUTDT_DIFF

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    CALL RESPONSEDT_INITIALISE(this%sim_response, setup, mesh)
    CALL OPR_STATESDT_INITIALISE(this%opr_final_states, setup, mesh)
  END SUBROUTINE OUTPUTDT_INITIALISE

  SUBROUTINE OUTPUTDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(IN) :: this
    TYPE(OUTPUTDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE OUTPUTDT_COPY

END MODULE MWD_OUTPUT_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - ControlDT
!%
!%          ========================== =====================================
!%          `Variables`                Description
!%          ========================== =====================================
!%          ``x``                      Control vector
!%          ``l``                      Control vector lower bound
!%          ``u``                      Control vector upper bound
!%          ``x_bkg``                  Control vector background
!%          ``l_bkg``                  Control vector lower bound background
!%          ``u_bkg``                  Control vector upper bound background
!%          ``nbd``                    Control vector kind of bound
!%
!ยง      Subroutine
!%      ----------
!%
!%      - ControlDT_initialise
!%      - ControlDT_copy
MODULE MWD_CONTROL_DIFF
!% only: sp
  USE MD_CONSTANT
  IMPLICIT NONE
!~         real(sp), dimension(:), allocatable :: x_bkg
  TYPE CONTROLDT
      REAL(sp), DIMENSION(:), ALLOCATABLE :: x
      REAL(sp), DIMENSION(:), ALLOCATABLE :: l
      REAL(sp), DIMENSION(:), ALLOCATABLE :: u
      REAL(sp), DIMENSION(:), ALLOCATABLE :: l_bkg
      REAL(sp), DIMENSION(:), ALLOCATABLE :: u_bkg
      INTEGER, DIMENSION(:), ALLOCATABLE :: nbd
  END TYPE CONTROLDT

CONTAINS
  SUBROUTINE CONTROLDT_INITIALISE(this, n)
    IMPLICIT NONE
    TYPE(CONTROLDT), INTENT(INOUT) :: this
    INTEGER, INTENT(IN) :: n
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
! Must check alloc before size
    IF (ALLOCATED(this%x)) THEN
      IF (SIZE(this%x) .EQ. n) RETURN
    END IF
    CALL CONTROLDT_FINALISE(this)
    ALLOCATE(this%x(n))
    this%x = -99._sp
!~         allocate (this%x_bkg(n))
!~         this%x_bkg = 0._sp
    ALLOCATE(this%l(n))
    this%l = -99._sp
    ALLOCATE(this%l_bkg(n))
    this%l_bkg = -99._sp
    ALLOCATE(this%u(n))
    this%u = -99._sp
    ALLOCATE(this%u_bkg(n))
    this%u_bkg = -99._sp
    ALLOCATE(this%nbd(n))
    this%nbd = -99
  END SUBROUTINE CONTROLDT_INITIALISE

  SUBROUTINE CONTROLDT_FINALISE(this)
    IMPLICIT NONE
    TYPE(CONTROLDT), INTENT(INOUT) :: this
    INTRINSIC ALLOCATED
    IF (ALLOCATED(this%x)) THEN
      DEALLOCATE(this%x)
!~         deallocate (this%x_bkg(n))
      DEALLOCATE(this%l)
      DEALLOCATE(this%l_bkg)
      DEALLOCATE(this%u)
      DEALLOCATE(this%u_bkg)
      DEALLOCATE(this%nbd)
    END IF
  END SUBROUTINE CONTROLDT_FINALISE

  SUBROUTINE CONTROLDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(CONTROLDT), INTENT(IN) :: this
    TYPE(CONTROLDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE CONTROLDT_COPY

! To manually deallocate from Python. ControlDT_finalize is used as
! __del__ method for garbage collecting (implemented by f90wrap automatically)
  SUBROUTINE CONTROLDT_DEALLOC(this)
    IMPLICIT NONE
    TYPE(CONTROLDT), INTENT(INOUT) :: this
    CALL CONTROLDT_FINALISE(this)
  END SUBROUTINE CONTROLDT_DEALLOC

END MODULE MWD_CONTROL_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%
!%      - Opr_ParametersDT
!%
!%          ========================== =====================================
!%          `Variables`                Description
!%          ========================== =====================================
!%          ``keys``                   Operator parameters keys
!%          ``values``                 Operator parameters values
!%
!%
!%      Subroutine
!%      ----------
!%
!%      - Opr_ParametersDT_initialise
!%      - Opr_ParametersDT_copy
MODULE MWD_OPR_PARAMETERS_DIFF
!% only: sp, lchar
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
!$F90W char-array
  TYPE OPR_PARAMETERSDT
      CHARACTER(len=lchar), DIMENSION(:), ALLOCATABLE :: keys
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: values
  END TYPE OPR_PARAMETERSDT
  TYPE OPR_PARAMETERSDT_DIFF
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: values
  END TYPE OPR_PARAMETERSDT_DIFF

CONTAINS
  SUBROUTINE OPR_PARAMETERSDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(OPR_PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this%keys(setup%nop))
    this%keys = '...'
    ALLOCATE(this%values(mesh%nrow, mesh%ncol, setup%nop))
    this%values = -99._sp
  END SUBROUTINE OPR_PARAMETERSDT_INITIALISE

  SUBROUTINE OPR_PARAMETERSDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(OPR_PARAMETERSDT), INTENT(IN) :: this
    TYPE(OPR_PARAMETERSDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE OPR_PARAMETERSDT_COPY

END MODULE MWD_OPR_PARAMETERS_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - ParametersDT
!%
!%          ========================== =====================================
!%          `Variables`                Description
!%          ========================== =====================================
!%          ``control``                ControlDT
!%          ``opr_parameters``         Opr_ParametersDT
!%          ``opr_initial_states``     Opr_StatesDT
!%
!ยง      Subroutine
!%      ----------
!%
!%      - ParametersDT_initialise
!%      - ParametersDT_copy
MODULE MWD_PARAMETERS_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: ControlDT
  USE MWD_CONTROL_DIFF
!% only: Opr_ParametersDT, Opr_ParametersDT_initialise
  USE MWD_OPR_PARAMETERS_DIFF
!% only: Opr_StatesDT, Opr_StatesDT_initialise
  USE MWD_OPR_STATES_DIFF
  IMPLICIT NONE
  TYPE PARAMETERSDT
      TYPE(CONTROLDT) :: control
      TYPE(OPR_PARAMETERSDT) :: opr_parameters
      TYPE(OPR_STATESDT) :: opr_initial_states
  END TYPE PARAMETERSDT
  TYPE PARAMETERSDT_DIFF
      TYPE(CONTROLDT) :: control
      TYPE(OPR_PARAMETERSDT_DIFF) :: opr_parameters
      TYPE(OPR_STATESDT_DIFF) :: opr_initial_states
  END TYPE PARAMETERSDT_DIFF

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    CALL OPR_PARAMETERSDT_INITIALISE(this%opr_parameters, setup, mesh)
    CALL OPR_STATESDT_INITIALISE(this%opr_initial_states, setup, mesh)
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE PARAMETERSDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: this
    TYPE(PARAMETERSDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE PARAMETERSDT_COPY

END MODULE MWD_PARAMETERS_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - kge_components
!%
!%      Function
!%      --------
!%
!%      - nse
!%      - nnse
!%      - kge
!%      - mae
!%      - mape
!%      - se
!%      - mse
!%      - rmse
!%      - lgrm
MODULE MWD_METRICS_DIFF
!% only: sp
  USE MD_CONSTANT
  IMPLICIT NONE

CONTAINS
!  Differentiation of nse in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION NSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_d, sum_xy_d, num_d
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    sum_yy_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num_d = sum_yy_d - 2*sum_xy_d
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res_d = -(num_d/den)
    res = 1._sp - num/den
  END FUNCTION NSE_D

!  Differentiation of nse in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE NSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_b, sum_xy_b, num_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
!% NSE numerator / denominator
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    num_b = -(res_b/den)
    sum_yy_b = num_b
    sum_xy_b = -(2*num_b)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b
    END DO
  END SUBROUTINE NSE_B

  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = 1._sp - num/den
  END FUNCTION NSE

!  Differentiation of nnse in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION NNSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    result1_d = NSE_D(x, y, y_d, result1)
    res_d = result1_d/(2._sp-result1)**2
    res = 1._sp/(2._sp-result1)
  END FUNCTION NNSE_D

!  Differentiation of nnse in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE NNSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    result1 = NSE(x, y)
    result1_b = res_b/(2._sp-result1)**2
    CALL NSE_B(x, y, y_b, result1_b)
  END SUBROUTINE NNSE_B

  FUNCTION NNSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: result1
    result1 = NSE(x, y)
    res = 1._sp/(2._sp-result1)
  END FUNCTION NNSE

!  Differentiation of kge_components in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: r a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp), INTENT(INOUT) :: r, a, b
    REAL(sp), INTENT(INOUT) :: r_d, a_d, b_d
    REAL(sp) :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, &
&   var_x, var_y, cov
    REAL(sp) :: sum_y_d, sum_yy_d, sum_xy_d, mean_y_d, var_x_d, var_y_d&
&   , cov_d
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: result2
    REAL(sp) :: result2_d
    REAL(sp) :: temp
! Metric computation
    n = 0
    sum_x = 0._sp
    sum_y = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    sum_yy_d = 0.0_4
    sum_y_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y_d = sum_y_d + y_d(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y_d = sum_y_d/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y_d = sum_yy_d/n - 2*mean_y*mean_y_d
    var_y = sum_yy/n - mean_y*mean_y
    cov_d = sum_xy_d/n - mean_x*mean_y_d
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result2_d = 0.0_4
    ELSE
      result2_d = var_y_d/(2.0*temp)
    END IF
    result2 = temp
    temp = cov/(result1*result2)
    r_d = (cov_d-temp*result1*result2_d)/(result1*result2)
    r = temp
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result1_d = 0.0_4
    ELSE
      result1_d = var_y_d/(2.0*temp)
    END IF
    result1 = temp
    result2 = SQRT(var_x)
    a_d = result1_d/result2
    a = result1/result2
    b_d = mean_y_d/mean_x
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS_D

!  Differentiation of kge_components in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: r y a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_B(x, y, y_b, r, r_b, a, a_b, b, b_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp), INTENT(INOUT) :: r, a, b
    REAL(sp), INTENT(INOUT) :: r_b, a_b, b_b
    REAL(sp) :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, &
&   var_x, var_y, cov
    REAL(sp) :: sum_y_b, sum_yy_b, sum_xy_b, mean_y_b, var_x_b, var_y_b&
&   , cov_b
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    REAL(sp) :: result2
    REAL(sp) :: result2_b
    REAL(sp) :: temp_b
    INTEGER :: ad_to
    INTEGER :: branch
! Metric computation
    n = 0
    sum_x = 0._sp
    sum_y = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    CALL PUSHREAL4(result2)
    result2 = SQRT(var_x)
    result1_b = a_b/result2
    CALL POPREAL4(result2)
    IF (var_y .EQ. 0.0) THEN
      var_y_b = 0.0_4
    ELSE
      var_y_b = result1_b/(2.0*SQRT(var_y))
    END IF
    temp_b = r_b/(result1*result2)
    cov_b = temp_b
    result2_b = -(cov*temp_b/result2)
    IF (.NOT.var_y .EQ. 0.0) var_y_b = var_y_b + result2_b/(2.0*SQRT(&
&       var_y))
    mean_y_b = b_b/mean_x - mean_x*cov_b - 2*mean_y*var_y_b
    sum_xy_b = cov_b/n
    sum_yy_b = var_y_b/n
    sum_y_b = mean_y_b/n
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b + sum_y_b
    END DO
  END SUBROUTINE KGE_COMPONENTS_B

  SUBROUTINE KGE_COMPONENTS(x, y, r, a, b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), INTENT(INOUT) :: r, a, b
    REAL(sp) :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, &
&   var_x, var_y, cov
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result2
! Metric computation
    n = 0
    sum_x = 0._sp
    sum_y = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    r = cov/result1/result2
    result1 = SQRT(var_y)
    result2 = SQRT(var_x)
    a = result1/result2
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS

!  Differentiation of kge in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION KGE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: r, a, b
    REAL(sp) :: r_d, a_d, b_d
    INTRINSIC SQRT
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: temp
    CALL KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
! KGE criterion
    arg1_d = 2*(r-1._sp)*r_d + 2*(b-1._sp)*b_d + 2*(a-1._sp)*a_d
    arg1 = (r-1._sp)*(r-1._sp) + (b-1._sp)*(b-1._sp) + (a-1._sp)*(a-&
&     1._sp)
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      result1_d = 0.0_4
    ELSE
      result1_d = arg1_d/(2.0*temp)
    END IF
    result1 = temp
    res_d = -result1_d
    res = 1._sp - result1
  END FUNCTION KGE_D

!  Differentiation of kge in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE KGE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: r, a, b
    REAL(sp) :: r_b, a_b, b_b
    INTRINSIC SQRT
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1._sp)*(r-1._sp) + (b-1._sp)*(b-1._sp) + (a-1._sp)*(a-&
&     1._sp)
    result1_b = -res_b
    arg1 = (r-1._sp)*(r-1._sp) + (b-1._sp)*(b-1._sp) + (a-1._sp)*(a-&
&     1._sp)
    IF (arg1 .EQ. 0.0) THEN
      arg1_b = 0.0_4
    ELSE
      arg1_b = result1_b/(2.0*SQRT(arg1))
    END IF
    r_b = 2*(r-1._sp)*arg1_b
    b_b = 2*(b-1._sp)*arg1_b
    a_b = 2*(a-1._sp)*arg1_b
    CALL KGE_COMPONENTS_B(x, y, y_b, r, r_b, a, a_b, b, b_b)
  END SUBROUTINE KGE_B

  FUNCTION KGE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: r, a, b
    INTRINSIC SQRT
    REAL(sp) :: arg1
    REAL(sp) :: result1
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1._sp)*(r-1._sp) + (b-1._sp)*(b-1._sp) + (a-1._sp)*(a-&
&     1._sp)
    result1 = SQRT(arg1)
    res = 1._sp - result1
  END FUNCTION KGE

!  Differentiation of mae in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION MAE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(sp) :: abs0
    REAL(sp) :: abs0_d
    n = 0
    res = 0._sp
    res_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        IF (x(i) - y(i) .GE. 0.) THEN
          abs0_d = -y_d(i)
          abs0 = x(i) - y(i)
        ELSE
          abs0_d = y_d(i)
          abs0 = -(x(i)-y(i))
        END IF
        res_d = res_d + abs0_d
        res = res + abs0
      END IF
    END DO
    res_d = res_d/n
    res = res/n
  END FUNCTION MAE_D

!  Differentiation of mae in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE MAE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(sp) :: abs0
    REAL(sp) :: abs0_b
    INTEGER :: branch
    INTEGER :: ad_to
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        n = n + 1
        IF (x(i) - y(i) .GE. 0.) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    res_b = res_b/n
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        abs0_b = res_b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_b(i) = y_b(i) - abs0_b
        ELSE
          y_b(i) = y_b(i) + abs0_b
        END IF
      END IF
    END DO
  END SUBROUTINE MAE_B

  FUNCTION MAE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(sp) :: abs0
    n = 0
    res = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        IF (x(i) - y(i) .GE. 0.) THEN
          abs0 = x(i) - y(i)
        ELSE
          abs0 = -(x(i)-y(i))
        END IF
        res = res + abs0
      END IF
    END DO
    res = res/n
  END FUNCTION MAE

!  Differentiation of mape in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION MAPE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(sp) :: abs0
    REAL(sp) :: abs0_d
    n = 0
    res = 0._sp
    res_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        IF ((x(i)-y(i))/x(i) .GE. 0.) THEN
          abs0_d = -(y_d(i)/x(i))
          abs0 = (x(i)-y(i))/x(i)
        ELSE
          abs0_d = y_d(i)/x(i)
          abs0 = -((x(i)-y(i))/x(i))
        END IF
        res_d = res_d + abs0_d
        res = res + abs0
      END IF
    END DO
    res_d = res_d/n
    res = res/n
  END FUNCTION MAPE_D

!  Differentiation of mape in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE MAPE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(sp) :: abs0
    REAL(sp) :: abs0_b
    INTEGER :: branch
    INTEGER :: ad_to
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        n = n + 1
        IF ((x(i)-y(i))/x(i) .GE. 0.) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    res_b = res_b/n
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        abs0_b = res_b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_b(i) = y_b(i) - abs0_b/x(i)
        ELSE
          y_b(i) = y_b(i) + abs0_b/x(i)
        END IF
      END IF
    END DO
  END SUBROUTINE MAPE_B

  FUNCTION MAPE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(sp) :: abs0
    n = 0
    res = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        IF ((x(i)-y(i))/x(i) .GE. 0.) THEN
          abs0 = (x(i)-y(i))/x(i)
        ELSE
          abs0 = -((x(i)-y(i))/x(i))
        END IF
        res = res + abs0
      END IF
    END DO
    res = res/n
  END FUNCTION MAPE

!  Differentiation of se in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION SE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    res = 0._sp
    res_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        res_d = res_d - 2*(x(i)-y(i))*y_d(i)
        res = res + (x(i)-y(i))*(x(i)-y(i))
      END IF
    END DO
  END FUNCTION SE_D

!  Differentiation of se in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE SE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(x)
      IF (x(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) - 2*(x(i)-y(i))*res_b
    END DO
  END SUBROUTINE SE_B

  FUNCTION SE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i
    INTRINSIC SIZE
    res = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) res = res + (x(i)-y(i))*(x(i)-y(i))
    END DO
  END FUNCTION SE

!  Differentiation of mse in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION MSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i, n
    INTRINSIC SIZE
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) n = n + 1
    END DO
    result1_d = SE_D(x, y, y_d, result1)
    res_d = result1_d/n
    res = result1/n
  END FUNCTION MSE_D

!  Differentiation of mse in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE MSE_B(x, y, y_b, res_b0)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b0
    INTEGER :: i, n
    INTRINSIC SIZE
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    REAL(sp) :: res0
    REAL(sp) :: res_b
    INTEGER :: ad_to
    INTEGER :: branch
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        n = n + 1
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    res0 = SE(x, y)
    result1_b = res_b0/n
    res_b = result1_b
    CALL SE_B(x, y, y_b, res_b)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
    END DO
  END SUBROUTINE MSE_B

  FUNCTION MSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i, n
    INTRINSIC SIZE
    REAL(sp) :: result1
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) n = n + 1
    END DO
    result1 = SE(x, y)
    res = result1/n
  END FUNCTION MSE

!  Differentiation of rmse in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION RMSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: temp
    result1_d = MSE_D(x, y, y_d, result1)
    temp = SQRT(result1)
    IF (result1 .EQ. 0.0) THEN
      res_d = 0.0_4
    ELSE
      res_d = result1_d/(2.0*temp)
    END IF
    res = temp
  END FUNCTION RMSE_D

!  Differentiation of rmse in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE RMSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    result1 = MSE(x, y)
    IF (result1 .EQ. 0.0) THEN
      result1_b = 0.0_4
    ELSE
      result1_b = res_b/(2.0*SQRT(result1))
    END IF
    CALL MSE_B(x, y, y_b, result1_b)
  END SUBROUTINE RMSE_B

  FUNCTION RMSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTRINSIC SQRT
    REAL(sp) :: result1
    result1 = MSE(x, y)
    res = SQRT(result1)
  END FUNCTION RMSE

!  Differentiation of lgrm in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION LGRM_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: arg2
    REAL(sp) :: arg2_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    res = 0._sp
    res_d = 0.0_4
    DO i=1,SIZE(x)
      IF (.NOT.(x(i) .LE. 0._sp .OR. y(i) .LE. 0._sp)) THEN
        arg1_d = y_d(i)/x(i)
        arg1 = y(i)/x(i)
        arg2_d = y_d(i)/x(i)
        arg2 = y(i)/x(i)
        temp = LOG(arg2)
        temp0 = LOG(arg1)
        res_d = res_d + x(i)*(temp*arg1_d/arg1+temp0*arg2_d/arg2)
        res = res + x(i)*(temp0*temp)
      END IF
    END DO
  END FUNCTION LGRM_D

!  Differentiation of lgrm in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE LGRM_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    REAL(sp) :: arg2
    REAL(sp) :: arg2_b
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(x)
      IF (x(i) .LE. 0._sp .OR. y(i) .LE. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        arg1_b = LOG(arg2)*x(i)*res_b/arg1
        arg2_b = LOG(arg1)*x(i)*res_b/arg2
        y_b(i) = y_b(i) + arg2_b/x(i) + arg1_b/x(i)
      END IF
    END DO
  END SUBROUTINE LGRM_B

  FUNCTION LGRM(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL(sp) :: arg1
    REAL(sp) :: arg2
    res = 0._sp
    DO i=1,SIZE(x)
      IF (.NOT.(x(i) .LE. 0._sp .OR. y(i) .LE. 0._sp)) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        res = res + x(i)*LOG(arg1)*LOG(arg2)
      END IF
    END DO
  END FUNCTION LGRM

END MODULE MWD_METRICS_DIFF

!%      (MD) Module Differentiated.
!%
!%      Interface
!%      ---------
!%
!%      - quantile1d_r
!%          . quantile1d_r_scl
!%          . quantile1d_r_1d
!%
!%      Subroutine
!%      ----------
!%
!%      - heap_sort
!%
!%      Function
!%      --------
!%
!%      - quantile1d_r_scl
!%      - quantile1d_r_1d
MODULE MD_STATS_DIFF
!% only: sp
  USE MD_CONSTANT
  IMPLICIT NONE
  INTERFACE QUANTILE1D_R
      MODULE PROCEDURE QUANTILE1D_R_SCL
      MODULE PROCEDURE QUANTILE1D_R_1D
  END INTERFACE QUANTILE1D_R

  INTERFACE QUANTILE1D_R_D
      MODULE PROCEDURE QUANTILE1D_R_SCL_D
  END INTERFACE

  INTERFACE QUANTILE1D_R_B
      MODULE PROCEDURE QUANTILE1D_R_SCL_B
  END INTERFACE


CONTAINS
!  Differentiation of heap_sort in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: arr
!   with respect to varying inputs: arr
  SUBROUTINE HEAP_SORT_D(n, arr, arr_d)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr_d
    INTEGER :: l, ir, i, j
    REAL(sp) :: arr_l
    REAL(sp) :: arr_l_d
    l = n/2 + 1
    ir = n
 10 IF (l .GT. 1) THEN
      l = l - 1
      arr_l_d = arr_d(l)
      arr_l = arr(l)
    ELSE
      arr_l_d = arr_d(ir)
      arr_l = arr(ir)
      arr_d(ir) = arr_d(1)
      arr(ir) = arr(1)
      ir = ir - 1
      IF (ir .EQ. 1) GOTO 100
    END IF
    i = l
    j = l + l
 20 IF (j .LE. ir) THEN
      IF (j .LT. ir) THEN
        IF (arr(j) .LT. arr(j+1)) j = j + 1
      END IF
      IF (arr_l .LT. arr(j)) THEN
        arr_d(i) = arr_d(j)
        arr(i) = arr(j)
        i = j
        j = j + j
      ELSE
        j = ir + 1
      END IF
      GOTO 20
    END IF
    arr_d(i) = arr_l_d
    arr(i) = arr_l
    GOTO 10
 100 arr_d(1) = arr_l_d
    arr(1) = arr_l
  END SUBROUTINE HEAP_SORT_D

!  Differentiation of heap_sort in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: arr
!   with respect to varying inputs: arr
  SUBROUTINE HEAP_SORT_B(n, arr, arr_b)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr_b
    INTEGER :: l, ir, i, j
    REAL(sp) :: arr_l
    REAL(sp) :: arr_l_b
    REAL(sp) :: tmp
    REAL(sp) :: tmp_b
    REAL(sp) :: tmp0
    REAL(sp) :: tmp_b0
    INTEGER :: branch
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: ad_count0
    INTEGER :: i1
    l = n/2 + 1
    ir = n
    ad_count0 = 1
 10 IF (l .GT. 1) THEN
      CALL PUSHINTEGER4(l)
      l = l - 1
      arr_l = arr(l)
      CALL PUSHCONTROL1B(0)
    ELSE
      arr_l = arr(ir)
      tmp = arr(1)
      arr(ir) = tmp
      CALL PUSHINTEGER4(ir)
      ir = ir - 1
      IF (ir .EQ. 1) THEN
        GOTO 100
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END IF
    CALL PUSHINTEGER4(i)
    i = l
    j = l + l
    ad_count = 1
 20 IF (j .LE. ir) THEN
      IF (j .LT. ir) THEN
        IF (arr(j) .LT. arr(j+1)) THEN
          CALL PUSHCONTROL1B(0)
          j = j + 1
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (arr_l .LT. arr(j)) THEN
        tmp0 = arr(j)
        arr(i) = tmp0
        CALL PUSHINTEGER4(i)
        i = j
        CALL PUSHINTEGER4(j)
        j = j + j
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
        j = ir + 1
      END IF
      ad_count = ad_count + 1
      GOTO 20
    END IF
    CALL PUSHINTEGER4(ad_count)
    arr(i) = arr_l
    ad_count0 = ad_count0 + 1
    GOTO 10
 100 CALL PUSHINTEGER4(ad_count0)
    arr_l_b = arr_b(1)
    arr_b(1) = 0.0_4
    CALL POPINTEGER4(ad_count0)
    DO 110 i1=1,ad_count0
      IF (i1 .NE. 1) THEN
        arr_l_b = arr_b(i)
        arr_b(i) = 0.0_4
        CALL POPINTEGER4(ad_count)
        DO i0=1,ad_count
          IF (i0 .NE. 1) THEN
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              CALL POPINTEGER4(j)
              CALL POPINTEGER4(i)
              tmp_b0 = arr_b(i)
              arr_b(i) = 0.0_4
              arr_b(j) = arr_b(j) + tmp_b0
            END IF
            CALL POPCONTROL1B(branch)
          END IF
        END DO
        CALL POPINTEGER4(i)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          arr_b(l) = arr_b(l) + arr_l_b
          CALL POPINTEGER4(l)
          GOTO 110
        END IF
      END IF
      CALL POPINTEGER4(ir)
      tmp_b = arr_b(ir)
      arr_b(ir) = 0.0_4
      arr_b(1) = arr_b(1) + tmp_b
      arr_b(ir) = arr_b(ir) + arr_l_b
 110 CONTINUE
  END SUBROUTINE HEAP_SORT_B

  SUBROUTINE HEAP_SORT(n, arr)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr
    INTEGER :: l, ir, i, j
    REAL(sp) :: arr_l
    l = n/2 + 1
    ir = n
 10 IF (l .GT. 1) THEN
      l = l - 1
      arr_l = arr(l)
    ELSE
      arr_l = arr(ir)
      arr(ir) = arr(1)
      ir = ir - 1
      IF (ir .EQ. 1) THEN
        arr(1) = arr_l
        RETURN
      END IF
    END IF
    i = l
    j = l + l
 20 IF (j .LE. ir) THEN
      IF (j .LT. ir) THEN
        IF (arr(j) .LT. arr(j+1)) j = j + 1
      END IF
      IF (arr_l .LT. arr(j)) THEN
        arr(i) = arr(j)
        i = j
        j = j + j
      ELSE
        j = ir + 1
      END IF
      GOTO 20
    ELSE
      arr(i) = arr_l
      GOTO 10
    END IF
  END SUBROUTINE HEAP_SORT

!  Differentiation of quantile1d_r_scl in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: dat
  FUNCTION QUANTILE1D_R_SCL_D(dat, dat_d, p, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat_d
    REAL(sp), INTENT(IN) :: p
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat_d
    INTEGER :: n
    REAL(sp) :: q1, q2, frac
    REAL(sp) :: q1_d, q2_d
    INTRINSIC INT
    REAL(sp) :: temp
    res_d = dat_d(1)
    res = dat(1)
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat_d = dat_d
      sorted_dat = dat
      CALL HEAP_SORT_D(n, sorted_dat, sorted_dat_d)
      frac = (n-1)*p + 1
      IF (frac .LE. 1) THEN
        res_d = sorted_dat_d(1)
        res = sorted_dat(1)
      ELSE IF (frac .GE. n) THEN
        res_d = sorted_dat_d(n)
        res = sorted_dat(n)
      ELSE
        q1_d = sorted_dat_d(INT(frac))
        q1 = sorted_dat(INT(frac))
        q2_d = sorted_dat_d(INT(frac)+1)
        q2 = sorted_dat(INT(frac)+1)
! linear interpolation
        temp = frac - INT(frac)
        res_d = q1_d + temp*(q2_d-q1_d)
        res = q1 + temp*(q2-q1)
      END IF
    END IF
  END FUNCTION QUANTILE1D_R_SCL_D

!  Differentiation of quantile1d_r_scl in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res
!   with respect to varying inputs: dat
  SUBROUTINE QUANTILE1D_R_SCL_B(dat, dat_b, p, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    REAL(sp), DIMENSION(:) :: dat_b
    REAL(sp), INTENT(IN) :: p
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat_b
    INTEGER :: n
    REAL(sp) :: q1, q2, frac
    REAL(sp) :: q1_b, q2_b
    INTRINSIC INT
    REAL(sp) :: temp_b
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat = dat
      CALL PUSHREAL4ARRAY(sorted_dat, SIZE(dat))
      CALL HEAP_SORT(n, sorted_dat)
      frac = (n-1)*p + 1
      IF (frac .LE. 1) THEN
        sorted_dat_b = 0.0_4
        sorted_dat_b(1) = sorted_dat_b(1) + res_b
      ELSE IF (frac .GE. n) THEN
        sorted_dat_b = 0.0_4
        sorted_dat_b(n) = sorted_dat_b(n) + res_b
      ELSE
        temp_b = (frac-INT(frac))*res_b
        q1_b = res_b - temp_b
        q2_b = temp_b
        sorted_dat_b = 0.0_4
        sorted_dat_b(INT(frac)+1) = sorted_dat_b(INT(frac)+1) + q2_b
        sorted_dat_b(INT(frac)) = sorted_dat_b(INT(frac)) + q1_b
      END IF
      CALL POPREAL4ARRAY(sorted_dat, SIZE(dat))
      CALL HEAP_SORT_B(n, sorted_dat, sorted_dat_b)
      dat_b = 0.0_4
      dat_b = sorted_dat_b
      res_b = 0.0_4
    ELSE
      dat_b = 0.0_4
    END IF
    dat_b(1) = dat_b(1) + res_b
  END SUBROUTINE QUANTILE1D_R_SCL_B

  FUNCTION QUANTILE1D_R_SCL(dat, p) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    REAL(sp), INTENT(IN) :: p
    REAL(sp) :: res
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    INTEGER :: n
    REAL(sp) :: q1, q2, frac
    INTRINSIC INT
    res = dat(1)
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat = dat
      CALL HEAP_SORT(n, sorted_dat)
      frac = (n-1)*p + 1
      IF (frac .LE. 1) THEN
        res = sorted_dat(1)
      ELSE IF (frac .GE. n) THEN
        res = sorted_dat(n)
      ELSE
        q1 = sorted_dat(INT(frac))
        q2 = sorted_dat(INT(frac)+1)
! linear interpolation
        res = q1 + (q2-q1)*(frac-INT(frac))
      END IF
    END IF
  END FUNCTION QUANTILE1D_R_SCL

  FUNCTION QUANTILE1D_R_1D(dat, p) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    REAL(sp), DIMENSION(:), INTENT(IN) :: p
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: res
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    INTEGER :: n, i
    REAL(sp) :: q1, q2, frac
    INTRINSIC INT
    res = dat(1)
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat = dat
      CALL HEAP_SORT(n, sorted_dat)
      DO i=1,SIZE(p)
        frac = (n-1)*p(i) + 1
        IF (frac .LE. 1) THEN
          res(i) = sorted_dat(1)
        ELSE IF (frac .GE. n) THEN
          res(i) = sorted_dat(n)
        ELSE
          q1 = sorted_dat(INT(frac))
          q2 = sorted_dat(INT(frac)+1)
! linear interpolation
          res(i) = q1 + (q2-q1)*(frac-INT(frac))
        END IF
      END DO
    END IF
  END FUNCTION QUANTILE1D_R_1D

END MODULE MD_STATS_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - baseflow_separation
!%
!%      Function
!%      --------
!%
!%      - rc
!%      - rchf
!%      - rclf
!%      - rch2r
!%      - cfp
!%      - eff
!%      - ebf
!%      - epf
!%      - elt
MODULE MWD_SIGNATURES_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: quantile1d_r
  USE MD_STATS_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of baseflow_separation in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: bt qft
!   with respect to varying inputs: streamflow
  SUBROUTINE BASEFLOW_SEPARATION_D(streamflow, streamflow_d, bt, bt_d, &
&   qft, qft_d, filter_parameter, passes)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: streamflow
    REAL(sp), DIMENSION(:), INTENT(IN) :: streamflow_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(streamflow)), INTENT(INOUT) :: bt, qft
    REAL(sp), DIMENSION(SIZE(streamflow)), INTENT(INOUT) :: bt_d, qft_d
    REAL(sp), INTENT(IN) :: filter_parameter
    INTEGER, INTENT(IN) :: passes
    REAL(sp), DIMENSION(SIZE(streamflow)) :: btp
    REAL(sp), DIMENSION(SIZE(streamflow)) :: btp_d
    INTEGER, DIMENSION(passes+1) :: ends
    INTEGER, DIMENSION(passes) :: addtostart
    INTEGER :: i, j
    LOGICAL :: odd
    INTRINSIC SUM
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: temp
    INTEGER :: temp0
    odd = .true.
! Start and end values for the filter function
    DO j=1,passes
      IF (odd) THEN
        ends(j) = 1
        addtostart(j) = 1
      ELSE
        ends(j) = SIZE(streamflow)
        addtostart(j) = -1
      END IF
      odd = .NOT.odd
    END DO
    ends(passes+1) = ends(passes-1)
    btp_d = streamflow_d
    btp = streamflow
    bt = 0._sp
    qft = 0._sp
! Guess baseflow value in the first time step
    result1 = QUANTILE1D_R(streamflow, 0.25_sp)
    IF (streamflow(1) .LT. result1) THEN
      bt_d = 0.0_4
      bt_d(1) = streamflow_d(1)
      bt(1) = streamflow(1)
      qft_d = 0.0_4
    ELSE
      bt_d = 0.0_4
      temp = 1.5_sp*SIZE(streamflow)
      bt_d(1) = SUM(streamflow_d)/temp
      bt(1) = SUM(streamflow)/temp
      qft_d = 0.0_4
    END IF
! Perform baseflow separation
    DO j=1,passes
      DO i=ends(j)+addtostart(j),ends(j+1),addtostart(j)
        IF (filter_parameter*bt(i-addtostart(j)) + (1._sp-&
&           filter_parameter)/2._sp*(btp(i)+btp(i-addtostart(j))) .GT. &
&           btp(i)) THEN
          bt_d(i) = btp_d(i)
          bt(i) = btp(i)
        ELSE
          bt_d(i) = filter_parameter*bt_d(i-addtostart(j)) + (1._sp-&
&           filter_parameter)*(btp_d(i)+btp_d(i-addtostart(j)))/2._sp
          bt(i) = filter_parameter*bt(i-addtostart(j)) + (1._sp-&
&           filter_parameter)/2._sp*(btp(i)+btp(i-addtostart(j)))
        END IF
        qft_d(i) = streamflow_d(i) - bt_d(i)
        qft(i) = streamflow(i) - bt(i)
      END DO
      IF (j .LT. passes) THEN
        btp_d = bt_d
        btp = bt
        IF (streamflow(ends(j+1)) .LT. SUM(btp)/SIZE(btp)) THEN
          bt_d(ends(j+1)) = streamflow_d(ends(j+1))/1.2_sp
          bt(ends(j+1)) = streamflow(ends(j+1))/1.2_sp
        ELSE
          temp0 = SIZE(btp)
          bt_d(ends(j+1)) = SUM(btp_d)/temp0
          bt(ends(j+1)) = SUM(btp)/temp0
        END IF
      END IF
    END DO
  END SUBROUTINE BASEFLOW_SEPARATION_D

!  Differentiation of baseflow_separation in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: streamflow bt qft
!   with respect to varying inputs: streamflow
  SUBROUTINE BASEFLOW_SEPARATION_B(streamflow, streamflow_b, bt, bt_b, &
&   qft, qft_b, filter_parameter, passes)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: streamflow
    REAL(sp), DIMENSION(:) :: streamflow_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(streamflow)), INTENT(INOUT) :: bt, qft
    REAL(sp), DIMENSION(SIZE(streamflow)), INTENT(INOUT) :: bt_b, qft_b
    REAL(sp), INTENT(IN) :: filter_parameter
    INTEGER, INTENT(IN) :: passes
    REAL(sp), DIMENSION(SIZE(streamflow)) :: btp
    REAL(sp), DIMENSION(SIZE(streamflow)) :: btp_b
    INTEGER, DIMENSION(passes+1) :: ends
    INTEGER, DIMENSION(passes) :: addtostart
    INTEGER :: i, j
    LOGICAL :: odd
    INTRINSIC SUM
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    REAL(sp) :: tmp
    REAL(sp) :: tmp_b
    REAL(sp) :: temp_b
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_stride
    INTEGER :: ad_to
    odd = .true.
! Start and end values for the filter function
    DO j=1,passes
      IF (odd) THEN
        ends(j) = 1
        addtostart(j) = 1
      ELSE
        ends(j) = SIZE(streamflow)
        addtostart(j) = -1
      END IF
      odd = .NOT.odd
    END DO
    ends(passes+1) = ends(passes-1)
    btp = streamflow
    bt = 0._sp
! Guess baseflow value in the first time step
    result1 = QUANTILE1D_R(streamflow, 0.25_sp)
    IF (streamflow(1) .LT. result1) THEN
      bt(1) = streamflow(1)
      CALL PUSHCONTROL1B(1)
    ELSE
      bt(1) = SUM(streamflow)/SIZE(streamflow)/1.5_sp
      CALL PUSHCONTROL1B(0)
    END IF
! Perform baseflow separation
    DO j=1,passes
      ad_from = ends(j) + addtostart(j)
      ad_stride = addtostart(j)
      DO i=ad_from,ends(j+1),ad_stride
        IF (filter_parameter*bt(i-addtostart(j)) + (1._sp-&
&           filter_parameter)/2._sp*(btp(i)+btp(i-addtostart(j))) .GT. &
&           btp(i)) THEN
          bt(i) = btp(i)
          CALL PUSHCONTROL1B(0)
        ELSE
          tmp = filter_parameter*bt(i-addtostart(j)) + (1._sp-&
&           filter_parameter)/2._sp*(btp(i)+btp(i-addtostart(j)))
          bt(i) = tmp
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
      CALL PUSHINTEGER4(i - ad_stride)
      CALL PUSHINTEGER4(ad_from)
      CALL PUSHINTEGER4(ad_stride)
      IF (j .LT. passes) THEN
        CALL PUSHREAL4ARRAY(btp, SIZE(streamflow))
        btp = bt
        IF (streamflow(ends(j+1)) .LT. SUM(btp)/SIZE(btp)) THEN
          bt(ends(j+1)) = streamflow(ends(j+1))/1.2_sp
          CALL PUSHCONTROL2B(2)
        ELSE
          bt(ends(j+1)) = SUM(btp)/SIZE(btp)
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    btp_b = 0.0_4
    DO j=passes,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          btp_b = btp_b + bt_b(ends(j+1))/SIZE(btp)
          bt_b(ends(j+1)) = 0.0_4
        ELSE
          streamflow_b(ends(j+1)) = streamflow_b(ends(j+1)) + bt_b(ends(&
&           j+1))/1.2_sp
          bt_b(ends(j+1)) = 0.0_4
        END IF
        CALL POPREAL4ARRAY(btp, SIZE(streamflow))
        bt_b = bt_b + btp_b
        btp_b = 0.0_4
      END IF
      CALL POPINTEGER4(ad_stride)
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,ad_from,-ad_stride
        streamflow_b(i) = streamflow_b(i) + qft_b(i)
        bt_b(i) = bt_b(i) - qft_b(i)
        qft_b(i) = 0.0_4
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          btp_b(i) = btp_b(i) + bt_b(i)
          bt_b(i) = 0.0_4
        ELSE
          tmp_b = bt_b(i)
          bt_b(i) = 0.0_4
          bt_b(i-addtostart(j)) = bt_b(i-addtostart(j)) + &
&           filter_parameter*tmp_b
          temp_b = (1._sp-filter_parameter)*tmp_b/2._sp
          btp_b(i) = btp_b(i) + temp_b
          btp_b(i-addtostart(j)) = btp_b(i-addtostart(j)) + temp_b
        END IF
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      streamflow_b = streamflow_b + bt_b(1)/(SIZE(streamflow)*1.5_sp)
    ELSE
      streamflow_b(1) = streamflow_b(1) + bt_b(1)
    END IF
    streamflow_b = streamflow_b + btp_b
    j = 0
  END SUBROUTINE BASEFLOW_SEPARATION_B

  SUBROUTINE BASEFLOW_SEPARATION(streamflow, bt, qft, filter_parameter, &
&   passes)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: streamflow
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(streamflow)), INTENT(INOUT) :: bt, qft
    REAL(sp), INTENT(IN) :: filter_parameter
    INTEGER, INTENT(IN) :: passes
    REAL(sp), DIMENSION(SIZE(streamflow)) :: btp
    INTEGER, DIMENSION(passes+1) :: ends
    INTEGER, DIMENSION(passes) :: addtostart
    INTEGER :: i, j
    LOGICAL :: odd
    INTRINSIC SUM
    REAL(sp) :: result1
    odd = .true.
! Start and end values for the filter function
    DO j=1,passes
      IF (odd) THEN
        ends(j) = 1
        addtostart(j) = 1
      ELSE
        ends(j) = SIZE(streamflow)
        addtostart(j) = -1
      END IF
      odd = .NOT.odd
    END DO
    ends(passes+1) = ends(passes-1)
    btp = streamflow
    bt = 0._sp
    qft = 0._sp
! Guess baseflow value in the first time step
    result1 = QUANTILE1D_R(streamflow, 0.25_sp)
    IF (streamflow(1) .LT. result1) THEN
      bt(1) = streamflow(1)
    ELSE
      bt(1) = SUM(streamflow)/SIZE(streamflow)/1.5_sp
    END IF
! Perform baseflow separation
    DO j=1,passes
      DO i=ends(j)+addtostart(j),ends(j+1),addtostart(j)
        IF (filter_parameter*bt(i-addtostart(j)) + (1._sp-&
&           filter_parameter)/2._sp*(btp(i)+btp(i-addtostart(j))) .GT. &
&           btp(i)) THEN
          bt(i) = btp(i)
        ELSE
          bt(i) = filter_parameter*bt(i-addtostart(j)) + (1._sp-&
&           filter_parameter)/2._sp*(btp(i)+btp(i-addtostart(j)))
        END IF
        qft(i) = streamflow(i) - bt(i)
      END DO
      IF (j .LT. passes) THEN
        btp = bt
        IF (streamflow(ends(j+1)) .LT. SUM(btp)/SIZE(btp)) THEN
          bt(ends(j+1)) = streamflow(ends(j+1))/1.2_sp
        ELSE
          bt(ends(j+1)) = SUM(btp)/SIZE(btp)
        END IF
      END IF
    END DO
  END SUBROUTINE BASEFLOW_SEPARATION

!  Differentiation of rc in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION RC_D(p, q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_d
    INTRINSIC SIZE
    n = SIZE(p)
    res = -99._sp
    numer = 0._sp
    denom = 0._sp
    numer_d = 0.0_4
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        numer_d = numer_d + q_d(i)
        numer = numer + q(i)
        denom = denom + p(i)
      END IF
    END DO
    IF (denom .GT. 0._sp) THEN
      res_d = numer_d/denom
      res = numer/denom
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION RC_D

!  Differentiation of rc in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE RC_B(p, q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_b
    INTRINSIC SIZE
    INTEGER :: branch
    n = SIZE(p)
    denom = 0._sp
    DO i=1,n
      IF (p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        denom = denom + p(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (denom .GT. 0._sp) THEN
      numer_b = res_b/denom
    ELSE
      numer_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) q_b(i) = q_b(i) + numer_b
    END DO
  END SUBROUTINE RC_B

  FUNCTION RC(p, q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp) :: res
    INTEGER :: n, i
    REAL(sp) :: numer, denom
    INTRINSIC SIZE
    n = SIZE(p)
    res = -99._sp
    numer = 0._sp
    denom = 0._sp
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        numer = numer + q(i)
        denom = denom + p(i)
      END IF
    END DO
    IF (denom .GT. 0._sp) res = numer/denom
  END FUNCTION RC

!  Differentiation of rchf in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION RCHF_D(p, q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_q_d, bf_d, qf_d
    n = SIZE(p)
    res = -99._sp
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    nonnegative_q_d = 0.0_4
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q_d(j) = q_d(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION_D(nonnegative_q(1:j), nonnegative_q_d(1:j&
&                          ), bf(1:j), bf_d(1:j), qf(1:j), qf_d(1:j), &
&                          0.925, 3)
      numer = 0._sp
      denom = 0._sp
      numer_d = 0.0_4
      DO i=1,j
        numer_d = numer_d + qf_d(i)
        numer = numer + qf(i)
        denom = denom + nonnegative_p(i)
      END DO
      IF (denom .GT. 0._sp) THEN
        res_d = numer_d/denom
        res = numer/denom
      ELSE
        res_d = 0.0_4
      END IF
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION RCHF_D

!  Differentiation of rchf in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE RCHF_B(p, q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_q_b, bf_b, qf_b
    INTEGER :: branch
    n = SIZE(p)
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q(j) = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      denom = 0._sp
      DO i=1,j
        denom = denom + nonnegative_p(i)
      END DO
      IF (denom .GT. 0._sp) THEN
        numer_b = res_b/denom
      ELSE
        numer_b = 0.0_4
      END IF
      qf_b = 0.0_4
      DO i=j,1,-1
        qf_b(i) = qf_b(i) + numer_b
      END DO
      nonnegative_q_b = 0.0_4
      bf_b = 0.0_4
      CALL BASEFLOW_SEPARATION_B(nonnegative_q(1:j), nonnegative_q_b(1:j&
&                          ), bf(1:j), bf_b(1:j), qf(1:j), qf_b(1:j), &
&                          0.925, 3)
      bf_b(1:j) = 0.0_4
      qf_b(1:j) = 0.0_4
    ELSE
      nonnegative_q_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + nonnegative_q_b(j)
        nonnegative_q_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE RCHF_B

  FUNCTION RCHF(p, q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp) :: res
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    n = SIZE(p)
    res = -99._sp
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      numer = 0._sp
      denom = 0._sp
      DO i=1,j
        numer = numer + qf(i)
        denom = denom + nonnegative_p(i)
      END DO
      IF (denom .GT. 0._sp) res = numer/denom
    END IF
  END FUNCTION RCHF

!  Differentiation of rclf in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION RCLF_D(p, q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_q_d, bf_d, qf_d
    n = SIZE(p)
    res = -99._sp
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    nonnegative_q_d = 0.0_4
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q_d(j) = q_d(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION_D(nonnegative_q(1:j), nonnegative_q_d(1:j&
&                          ), bf(1:j), bf_d(1:j), qf(1:j), qf_d(1:j), &
&                          0.925, 3)
      numer = 0._sp
      denom = 0._sp
      numer_d = 0.0_4
      DO i=1,j
        numer_d = numer_d + bf_d(i)
        numer = numer + bf(i)
        denom = denom + nonnegative_p(i)
      END DO
      IF (denom .GT. 0._sp) THEN
        res_d = numer_d/denom
        res = numer/denom
      ELSE
        res_d = 0.0_4
      END IF
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION RCLF_D

!  Differentiation of rclf in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE RCLF_B(p, q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_q_b, bf_b, qf_b
    INTEGER :: branch
    n = SIZE(p)
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q(j) = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      denom = 0._sp
      DO i=1,j
        denom = denom + nonnegative_p(i)
      END DO
      IF (denom .GT. 0._sp) THEN
        numer_b = res_b/denom
      ELSE
        numer_b = 0.0_4
      END IF
      bf_b = 0.0_4
      DO i=j,1,-1
        bf_b(i) = bf_b(i) + numer_b
      END DO
      nonnegative_q_b = 0.0_4
      qf_b = 0.0_4
      CALL BASEFLOW_SEPARATION_B(nonnegative_q(1:j), nonnegative_q_b(1:j&
&                          ), bf(1:j), bf_b(1:j), qf(1:j), qf_b(1:j), &
&                          0.925, 3)
      bf_b(1:j) = 0.0_4
      qf_b(1:j) = 0.0_4
    ELSE
      nonnegative_q_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + nonnegative_q_b(j)
        nonnegative_q_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE RCLF_B

  FUNCTION RCLF(p, q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp) :: res
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    n = SIZE(p)
    res = -99._sp
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      numer = 0._sp
      denom = 0._sp
      DO i=1,j
        numer = numer + bf(i)
        denom = denom + nonnegative_p(i)
      END DO
      IF (denom .GT. 0._sp) res = numer/denom
    END IF
  END FUNCTION RCLF

!  Differentiation of rch2r in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION RCH2R_D(p, q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_d, denom_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_q_d, bf_d, qf_d
    n = SIZE(p)
    res = -99._sp
    nonnegative_q = 0._sp
    j = 0
    nonnegative_q_d = 0.0_4
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        j = j + 1
        nonnegative_q_d(j) = q_d(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION_D(nonnegative_q(1:j), nonnegative_q_d(1:j&
&                          ), bf(1:j), bf_d(1:j), qf(1:j), qf_d(1:j), &
&                          0.925, 3)
      numer = 0._sp
      denom = 0._sp
      denom_d = 0.0_4
      numer_d = 0.0_4
      DO i=1,j
        numer_d = numer_d + qf_d(i)
        numer = numer + qf(i)
        denom_d = denom_d + nonnegative_q_d(i)
        denom = denom + nonnegative_q(i)
      END DO
      IF (denom .GT. 0._sp) THEN
        res_d = (numer_d-numer*denom_d/denom)/denom
        res = numer/denom
      ELSE
        res_d = 0.0_4
      END IF
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION RCH2R_D

!  Differentiation of rch2r in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE RCH2R_B(p, q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    REAL(sp) :: numer_b, denom_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_q_b, bf_b, qf_b
    INTEGER :: branch
    n = SIZE(p)
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        nonnegative_q(j) = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      numer = 0._sp
      denom = 0._sp
      DO i=1,j
        numer = numer + qf(i)
        denom = denom + nonnegative_q(i)
      END DO
      IF (denom .GT. 0._sp) THEN
        numer_b = res_b/denom
        denom_b = -(numer*res_b/denom**2)
      ELSE
        denom_b = 0.0_4
        numer_b = 0.0_4
      END IF
      qf_b = 0.0_4
      nonnegative_q_b = 0.0_4
      DO i=j,1,-1
        nonnegative_q_b(i) = nonnegative_q_b(i) + denom_b
        qf_b(i) = qf_b(i) + numer_b
      END DO
      bf_b = 0.0_4
      CALL BASEFLOW_SEPARATION_B(nonnegative_q(1:j), nonnegative_q_b(1:j&
&                          ), bf(1:j), bf_b(1:j), qf(1:j), qf_b(1:j), &
&                          0.925, 3)
      bf_b(1:j) = 0.0_4
      qf_b(1:j) = 0.0_4
    ELSE
      nonnegative_q_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + nonnegative_q_b(j)
        nonnegative_q_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE RCH2R_B

  FUNCTION RCH2R(p, q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp) :: res
    INTEGER :: n, i, j
    REAL(sp) :: numer, denom
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(p)) :: nonnegative_p, nonnegative_q, bf, qf
    n = SIZE(p)
    res = -99._sp
    nonnegative_p = 0._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (.NOT.(p(i) .LT. 0._sp .OR. q(i) .LT. 0._sp)) THEN
        j = j + 1
        nonnegative_p(j) = p(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      numer = 0._sp
      denom = 0._sp
      DO i=1,j
        numer = numer + qf(i)
        denom = denom + nonnegative_q(i)
      END DO
      IF (denom .GT. 0._sp) res = numer/denom
    END IF
  END FUNCTION RCH2R

!  Differentiation of cfp in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION CFP_D(q, q_d, quant, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp), INTENT(IN) :: quant
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q_d
    n = SIZE(q)
    res = -99._sp
    j = 0
    nonnegative_q_d = 0.0_4
    DO i=1,n
      IF (q(i) .GE. 0._sp) THEN
        j = j + 1
        nonnegative_q_d(j) = q_d(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      res_d = QUANTILE1D_R_D(nonnegative_q(1:j), nonnegative_q_d(1:j), &
&       quant, res)
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION CFP_D

!  Differentiation of cfp in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE CFP_B(q, q_b, quant, res_b0)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp), INTENT(IN) :: quant
    REAL(sp) :: res
    REAL(sp) :: res_b0
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q_b
    REAL(sp) :: res0
    REAL(sp) :: res_b
    INTEGER :: branch
    n = SIZE(q)
    j = 0
    DO i=1,n
      IF (q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        nonnegative_q(j) = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (j .GT. 1) THEN
      res0 = QUANTILE1D_R(nonnegative_q(1:j), quant)
      nonnegative_q_b = 0.0_4
      res_b = res_b0
      CALL QUANTILE1D_R_B(nonnegative_q(1:j), nonnegative_q_b(1:j), &
&                   quant, res_b)
    ELSE
      nonnegative_q_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + nonnegative_q_b(j)
        nonnegative_q_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE CFP_B

  FUNCTION CFP(q, quant) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), INTENT(IN) :: quant
    REAL(sp) :: res
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q
    n = SIZE(q)
    res = -99._sp
    j = 0
    DO i=1,n
      IF (q(i) .GE. 0._sp) THEN
        j = j + 1
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) res = QUANTILE1D_R(nonnegative_q(1:j), quant)
  END FUNCTION CFP

!  Differentiation of eff in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION EFF_D(q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q_d, bf_d, qf_d
    INTRINSIC SUM
    n = SIZE(q)
    res = -99._sp
    nonnegative_q = 0._sp
    j = 0
    nonnegative_q_d = 0.0_4
    DO i=1,n
      IF (q(i) .GE. 0._sp) THEN
        j = j + 1
        nonnegative_q_d(j) = q_d(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION_D(nonnegative_q(1:j), nonnegative_q_d(1:j&
&                          ), bf(1:j), bf_d(1:j), qf(1:j), qf_d(1:j), &
&                          0.925, 3)
      res_d = SUM(qf_d(1:j))/j
      res = SUM(qf(1:j))/j
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION EFF_D

!  Differentiation of eff in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE EFF_B(q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q_b, bf_b, qf_b
    INTRINSIC SUM
    INTEGER :: branch
    n = SIZE(q)
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        nonnegative_q(j) = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      qf_b = 0.0_4
      qf_b(1:j) = qf_b(1:j) + res_b/j
      nonnegative_q_b = 0.0_4
      bf_b = 0.0_4
      CALL BASEFLOW_SEPARATION_B(nonnegative_q(1:j), nonnegative_q_b(1:j&
&                          ), bf(1:j), bf_b(1:j), qf(1:j), qf_b(1:j), &
&                          0.925, 3)
      bf_b(1:j) = 0.0_4
      qf_b(1:j) = 0.0_4
    ELSE
      nonnegative_q_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + nonnegative_q_b(j)
        nonnegative_q_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE EFF_B

  FUNCTION EFF(q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp) :: res
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q, bf, qf
    INTRINSIC SUM
    n = SIZE(q)
    res = -99._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (q(i) .GE. 0._sp) THEN
        j = j + 1
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      res = SUM(qf(1:j))/j
    END IF
  END FUNCTION EFF

!  Differentiation of ebf in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION EBF_D(q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q_d, bf_d, qf_d
    INTRINSIC SUM
    n = SIZE(q)
    res = -99._sp
    nonnegative_q = 0._sp
    j = 0
    nonnegative_q_d = 0.0_4
    DO i=1,n
      IF (q(i) .GE. 0._sp) THEN
        j = j + 1
        nonnegative_q_d(j) = q_d(i)
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION_D(nonnegative_q(1:j), nonnegative_q_d(1:j&
&                          ), bf(1:j), bf_d(1:j), qf(1:j), qf_d(1:j), &
&                          0.925, 3)
      res_d = SUM(bf_d(1:j))/j
      res = SUM(bf(1:j))/j
    ELSE
      res_d = 0.0_4
    END IF
  END FUNCTION EBF_D

!  Differentiation of ebf in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE EBF_B(q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q, bf, qf
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q_b, bf_b, qf_b
    INTRINSIC SUM
    INTEGER :: branch
    n = SIZE(q)
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (q(i) .LT. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        nonnegative_q(j) = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      bf_b = 0.0_4
      bf_b(1:j) = bf_b(1:j) + res_b/j
      nonnegative_q_b = 0.0_4
      qf_b = 0.0_4
      CALL BASEFLOW_SEPARATION_B(nonnegative_q(1:j), nonnegative_q_b(1:j&
&                          ), bf(1:j), bf_b(1:j), qf(1:j), qf_b(1:j), &
&                          0.925, 3)
      bf_b(1:j) = 0.0_4
      qf_b(1:j) = 0.0_4
    ELSE
      nonnegative_q_b = 0.0_4
    END IF
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + nonnegative_q_b(j)
        nonnegative_q_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE EBF_B

  FUNCTION EBF(q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp) :: res
    INTEGER :: n, i, j
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(q)) :: nonnegative_q, bf, qf
    INTRINSIC SUM
    n = SIZE(q)
    res = -99._sp
    nonnegative_q = 0._sp
    j = 0
    DO i=1,n
      IF (q(i) .GE. 0._sp) THEN
        j = j + 1
        nonnegative_q(j) = q(i)
      END IF
    END DO
    IF (j .GT. 1) THEN
      CALL BASEFLOW_SEPARATION(nonnegative_q(1:j), bf(1:j), qf(1:j), &
&                        0.925, 3)
      res = SUM(bf(1:j))/j
    END IF
  END FUNCTION EBF

!  Differentiation of epf in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: q
  FUNCTION EPF_D(q, q_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:), INTENT(IN) :: q_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: n, i
    INTRINSIC SIZE
    n = SIZE(q)
    res = -99._sp
    res_d = 0.0_4
    DO i=1,n
      IF (q(i) .GT. res) THEN
        res_d = q_d(i)
        res = q(i)
      END IF
    END DO
  END FUNCTION EPF_D

!  Differentiation of epf in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res q
!   with respect to varying inputs: q
  SUBROUTINE EPF_B(q, q_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp), DIMENSION(:) :: q_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: n, i
    INTRINSIC SIZE
    INTEGER :: branch
    n = SIZE(q)
    res = -99._sp
    DO i=1,n
      IF (q(i) .LE. res) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        res = q(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        q_b(i) = q_b(i) + res_b
        res_b = 0.0_4
      END IF
    END DO
  END SUBROUTINE EPF_B

  FUNCTION EPF(q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: q
    REAL(sp) :: res
    INTEGER :: n, i
    INTRINSIC SIZE
    n = SIZE(q)
    res = -99._sp
    DO i=1,n
      IF (q(i) .GT. res) res = q(i)
    END DO
  END FUNCTION EPF

  FUNCTION ELT(p, q) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: p, q
    REAL(sp) :: res
    INTEGER :: n, i, imax_p, imax_q
    REAL(sp) :: max_p, max_q
    INTRINSIC SIZE
    n = SIZE(q)
    res = -99._sp
    max_p = -99._sp
    max_q = -99._sp
    imax_p = 0
    imax_q = 0
    DO i=1,n
      IF (p(i) .GT. max_p) THEN
        max_p = p(i)
        imax_p = i
      END IF
      IF (q(i) .GT. max_q) THEN
        max_q = q(i)
        imax_q = i
      END IF
    END DO
    IF (imax_p .GT. 0 .AND. imax_q .GT. 0) res = imax_q - imax_p
  END FUNCTION ELT

END MODULE MWD_SIGNATURES_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - cls_compute_jobs
!%      - cls_compute_cost
!%      - compute_cost
!%
!%      Function
!%      --------
!%
!%      - get_range_event
MODULE MWD_COST_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: quantile1d_r
  USE MD_STATS_DIFF
!% only: nse, nnse, kge, mae, mape, mse, rmse, lgrm
  USE MWD_METRICS_DIFF
!% only: rc, rchf, rclf, rch2r, cfp, ebf, elt, eff
  USE MWD_SIGNATURES_DIFF
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
  IMPLICIT NONE

CONTAINS
  FUNCTION GET_RANGE_EVENT(mask_event, i_event) RESULT (RES)
    IMPLICIT NONE
    INTEGER, DIMENSION(:), INTENT(IN) :: mask_event
    INTEGER, INTENT(IN) :: i_event
    INTEGER, DIMENSION(2) :: res
    INTEGER :: i
    INTRINSIC SIZE
    res = 0
    DO i=1,SIZE(mask_event)
      IF (mask_event(i) .EQ. i_event) THEN
        res(1) = i
        GOTO 100
      END IF
    END DO
 100 DO i=SIZE(mask_event),1,-1
      IF (mask_event(i) .EQ. i_event) THEN
        res(2) = i
        GOTO 110
      END IF
    END DO
 110 CONTINUE
  END FUNCTION GET_RANGE_EVENT

!  Differentiation of cls_compute_jobs in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: jobs
!   with respect to varying inputs: *(output.sim_response.q)
!   Plus diff mem management of: output.sim_response.q:in
  SUBROUTINE CLS_COMPUTE_JOBS_D(setup, mesh, input_data, output, &
&   output_d, options, returns, jobs, jobs_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(IN) :: output
    TYPE(OUTPUTDT), INTENT(IN) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    REAL(sp), INTENT(INOUT) :: jobs
    REAL(sp), INTENT(INOUT) :: jobs_d
    INTEGER :: i, j, k, n_computed_event
    REAL(sp), DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   qo, qs, mprcp
    REAL(sp), DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   qo_d, qs_d
    INTEGER, DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   mask_event
    REAL(sp), DIMENSION(mesh%ng, options%cost%njoc) :: jobs_cmpt_values
    REAL(sp), DIMENSION(mesh%ng, options%cost%njoc) :: &
&   jobs_cmpt_values_d
    INTEGER, DIMENSION(2) :: range_event
    REAL(sp), DIMENSION(mesh%ng) :: jobs_gauge
    REAL(sp), DIMENSION(mesh%ng) :: jobs_gauge_d
    REAL(sp) :: jobs_tmp
    REAL(sp) :: jobs_tmp_d
    INTRINSIC ABS
    INTRINSIC ANY
    REAL(sp) :: abs0
    REAL(sp) :: abs1
    REAL(sp) :: abs2
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: temp
    jobs_cmpt_values = 0._sp
    jobs_cmpt_values_d = 0.0_4
    DO i=1,mesh%ng
      IF (options%cost%wgauge(i) .GE. 0.) THEN
        abs0 = options%cost%wgauge(i)
      ELSE
        abs0 = -options%cost%wgauge(i)
      END IF
! Cycle if wgauge is equal to 0
      IF (abs0 .GT. 0._sp) THEN
        qo = input_data%obs_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        qs_d = output_d%sim_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        qs = output%sim_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        WHERE (qo .LT. 0._sp) 
          qs_d = 0.0_4
          qs = -99._sp
        END WHERE
! Convert mean_prcp from mm/dt to m3/s
        mprcp = input_data%atmos_data%mean_prcp(i, options%cost%&
&         end_warmup:setup%ntime_step)*mesh%area_dln(i)*1.e-3_sp/setup%&
&         dt
        mask_event = options%cost%mask_event(i, options%cost%end_warmup:&
&         setup%ntime_step)
        DO j=1,options%cost%njoc
! Should be unreachable.
          SELECT CASE  (options%cost%jobs_cmpt(j)) 
          CASE ('nse') 
! Efficiency Metrics
            result1_d = NSE_D(qo, qs, qs_d, result1)
            jobs_cmpt_values_d(i, j) = -result1_d
            jobs_cmpt_values(i, j) = 1._sp - result1
          CASE ('nnse') 
            result1_d = NNSE_D(qo, qs, qs_d, result1)
            jobs_cmpt_values_d(i, j) = -result1_d
            jobs_cmpt_values(i, j) = 1._sp - result1
          CASE ('kge') 
            result1_d = KGE_D(qo, qs, qs_d, result1)
            jobs_cmpt_values_d(i, j) = -result1_d
            jobs_cmpt_values(i, j) = 1._sp - result1
          CASE ('mae') 
            jobs_cmpt_values_d(i, j) = MAE_D(qo, qs, qs_d, &
&             jobs_cmpt_values(i, j))
          CASE ('mape') 
            jobs_cmpt_values_d(i, j) = MAPE_D(qo, qs, qs_d, &
&             jobs_cmpt_values(i, j))
          CASE ('mse') 
            jobs_cmpt_values_d(i, j) = MSE_D(qo, qs, qs_d, &
&             jobs_cmpt_values(i, j))
          CASE ('rmse') 
            jobs_cmpt_values_d(i, j) = RMSE_D(qo, qs, qs_d, &
&             jobs_cmpt_values(i, j))
          CASE ('lgrm') 
            jobs_cmpt_values_d(i, j) = LGRM_D(qo, qs, qs_d, &
&             jobs_cmpt_values(i, j))
          CASE ('Crc') 
! Continuous Signatures
            jobs_tmp = RC(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = RC_D(mprcp, qs, qs_d, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Crchf') 
            jobs_tmp = RCHF(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = RCHF_D(mprcp, qs, qs_d, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Crclf') 
            jobs_tmp = RCLF(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = RCLF_D(mprcp, qs, qs_d, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Crch2r') 
            jobs_tmp = RCH2R(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = RCH2R_D(mprcp, qs, qs_d, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp2') 
            jobs_tmp = CFP(qo, 0.02_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = CFP_D(qs, qs_d, 0.02_sp, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp10') 
            jobs_tmp = CFP(qo, 0.1_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = CFP_D(qs, qs_d, 0.1_sp, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp50') 
            jobs_tmp = CFP(qo, 0.5_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = CFP_D(qs, qs_d, 0.5_sp, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp90') 
            jobs_tmp = CFP(qo, 0.9_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1_d = CFP_D(qs, qs_d, 0.9_sp, result1)
              jobs_cmpt_values_d(i, j) = 2*(result1/jobs_tmp-1._sp)*&
&               result1_d/jobs_tmp
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Erc') 
! Event Signatures
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RC(mprcp(range_event(1):range_event(2)), qo(&
&                 range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = RC_D(mprcp(range_event(1):range_event(2))&
&                   , qs(range_event(1):range_event(2)), qs_d(&
&                   range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Erchf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RCHF(mprcp(range_event(1):range_event(2)), qo&
&                 (range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = RCHF_D(mprcp(range_event(1):range_event(2)&
&                   ), qs(range_event(1):range_event(2)), qs_d(&
&                   range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Erclf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RCLF(mprcp(range_event(1):range_event(2)), qo&
&                 (range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = RCLF_D(mprcp(range_event(1):range_event(2)&
&                   ), qs(range_event(1):range_event(2)), qs_d(&
&                   range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Erch2r') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RCH2R(mprcp(range_event(1):range_event(2)), &
&                 qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = RCH2R_D(mprcp(range_event(1):range_event(2&
&                   )), qs(range_event(1):range_event(2)), qs_d(&
&                   range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Eff') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = EFF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = EFF_D(qs(range_event(1):range_event(2)), &
&                   qs_d(range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Ebf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = EBF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = EBF_D(qs(range_event(1):range_event(2)), &
&                   qs_d(range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Elt') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = ELT(mprcp(range_event(1):range_event(2)), qo(&
&                 range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = ELT(mprcp(range_event(1):range_event(2)), qs&
&                   (range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Epf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = EPF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1_d = EPF_D(qs(range_event(1):range_event(2)), &
&                   qs_d(range_event(1):range_event(2)), result1)
                  jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j) + &
&                   2*(result1/jobs_tmp-1._sp)*result1_d/jobs_tmp
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values_d(i, j) = jobs_cmpt_values_d(i, j)/&
&             n_computed_event
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          END SELECT
        END DO
      END IF
    END DO
! TODO TH: handle with alias (median, low/upp quartiles) for jobs_cmpt
    IF (ANY(options%cost%wgauge(:) .LT. 0._sp)) THEN
      jobs_gauge = 0._sp
      k = 0
      jobs_gauge_d = 0.0_4
      DO i=1,mesh%ng
        IF (options%cost%wgauge(i) .GE. 0.) THEN
          abs1 = options%cost%wgauge(i)
        ELSE
          abs1 = -options%cost%wgauge(i)
        END IF
        IF (abs1 .GT. 0._sp) THEN
          jobs_tmp = 0._sp
          jobs_tmp_d = 0.0_4
          DO j=1,options%cost%njoc
            jobs_tmp_d = jobs_tmp_d + options%cost%wjobs_cmpt(j)*&
&             jobs_cmpt_values_d(i, j)
            jobs_tmp = jobs_tmp + options%cost%wjobs_cmpt(j)*&
&             jobs_cmpt_values(i, j)
          END DO
          k = k + 1
          jobs_gauge_d(k) = jobs_tmp_d
          jobs_gauge(k) = jobs_tmp
        END IF
      END DO
      IF (options%cost%wgauge(1) .GE. 0.) THEN
        abs2 = options%cost%wgauge(1)
      ELSE
        abs2 = -options%cost%wgauge(1)
      END IF
      jobs_d = QUANTILE1D_R_D(jobs_gauge(1:k), jobs_gauge_d(1:k), abs2, &
&       jobs)
    ELSE
      jobs_d = 0.0_4
      DO i=1,mesh%ng
        DO j=1,options%cost%njoc
          temp = options%cost%wgauge(i)*options%cost%wjobs_cmpt(j)
          jobs_d = jobs_d + temp*jobs_cmpt_values_d(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE CLS_COMPUTE_JOBS_D

!  Differentiation of cls_compute_jobs in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: jobs
!   with respect to varying inputs: *(output.sim_response.q)
!   Plus diff mem management of: output.sim_response.q:in
  SUBROUTINE CLS_COMPUTE_JOBS_B(setup, mesh, input_data, output, &
&   output_b, options, returns, jobs, jobs_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(IN) :: output
    TYPE(OUTPUTDT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    REAL(sp), INTENT(INOUT) :: jobs
    REAL(sp), INTENT(INOUT) :: jobs_b
    INTEGER :: i, j, k, n_computed_event
    REAL(sp), DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   qo, qs, mprcp
    REAL(sp), DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   qo_b, qs_b
    INTEGER, DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   mask_event
    REAL(sp), DIMENSION(mesh%ng, options%cost%njoc) :: jobs_cmpt_values
    REAL(sp), DIMENSION(mesh%ng, options%cost%njoc) :: &
&   jobs_cmpt_values_b
    INTEGER, DIMENSION(2) :: range_event
    REAL(sp), DIMENSION(mesh%ng) :: jobs_gauge
    REAL(sp), DIMENSION(mesh%ng) :: jobs_gauge_b
    REAL(sp) :: jobs_tmp
    REAL(sp) :: jobs_tmp_b
    INTRINSIC ABS
    INTRINSIC ANY
    REAL(sp) :: abs0
    REAL(sp) :: abs1
    REAL(sp) :: abs2
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: ad_to
    INTEGER :: branch
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    INTEGER :: ad_to2
    INTEGER :: ad_to3
    INTEGER :: ad_to4
    INTEGER :: ad_to5
    INTEGER :: ad_to6
    jobs_cmpt_values = 0._sp
    DO i=1,mesh%ng
      IF (options%cost%wgauge(i) .GE. 0.) THEN
        abs0 = options%cost%wgauge(i)
      ELSE
        abs0 = -options%cost%wgauge(i)
      END IF
! Cycle if wgauge is equal to 0
      IF (abs0 .LE. 0._sp) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL4ARRAY(qo, setup%ntime_step - options%cost%&
&                     end_warmup + 1)
        qo = input_data%obs_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        CALL PUSHREAL4ARRAY(qs, setup%ntime_step - options%cost%&
&                     end_warmup + 1)
        qs = output%sim_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        WHERE (qo .LT. 0._sp) qs = -99._sp
! Convert mean_prcp from mm/dt to m3/s
        CALL PUSHREAL4ARRAY(mprcp, setup%ntime_step - options%cost%&
&                     end_warmup + 1)
        mprcp = input_data%atmos_data%mean_prcp(i, options%cost%&
&         end_warmup:setup%ntime_step)*mesh%area_dln(i)*1.e-3_sp/setup%&
&         dt
        mask_event = options%cost%mask_event(i, options%cost%end_warmup:&
&         setup%ntime_step)
        DO j=1,options%cost%njoc
! Should be unreachable.
          SELECT CASE  (options%cost%jobs_cmpt(j)) 
          CASE ('nse') 
! Efficiency Metrics
            CALL PUSHREAL4(result1)
            result1 = NSE(qo, qs)
            jobs_cmpt_values(i, j) = 1._sp - result1
            CALL PUSHCONTROL6B(32)
          CASE ('nnse') 
            CALL PUSHREAL4(result1)
            result1 = NNSE(qo, qs)
            jobs_cmpt_values(i, j) = 1._sp - result1
            CALL PUSHCONTROL6B(31)
          CASE ('kge') 
            CALL PUSHREAL4(result1)
            result1 = KGE(qo, qs)
            jobs_cmpt_values(i, j) = 1._sp - result1
            CALL PUSHCONTROL6B(30)
          CASE ('mae') 
            jobs_cmpt_values(i, j) = MAE(qo, qs)
            CALL PUSHCONTROL6B(29)
          CASE ('mape') 
            jobs_cmpt_values(i, j) = MAPE(qo, qs)
            CALL PUSHCONTROL6B(28)
          CASE ('mse') 
            jobs_cmpt_values(i, j) = MSE(qo, qs)
            CALL PUSHCONTROL6B(27)
          CASE ('rmse') 
            jobs_cmpt_values(i, j) = RMSE(qo, qs)
            CALL PUSHCONTROL6B(26)
          CASE ('lgrm') 
            jobs_cmpt_values(i, j) = LGRM(qo, qs)
            CALL PUSHCONTROL6B(25)
          CASE ('Crc') 
! Continuous Signatures
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = RC(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = RC(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(24)
            ELSE
              CALL PUSHCONTROL6B(23)
            END IF
          CASE ('Crchf') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = RCHF(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = RCHF(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(22)
            ELSE
              CALL PUSHCONTROL6B(21)
            END IF
          CASE ('Crclf') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = RCLF(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = RCLF(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(20)
            ELSE
              CALL PUSHCONTROL6B(19)
            END IF
          CASE ('Crch2r') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = RCH2R(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = RCH2R(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(18)
            ELSE
              CALL PUSHCONTROL6B(17)
            END IF
          CASE ('Cfp2') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = CFP(qo, 0.02_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = CFP(qs, 0.02_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(16)
            ELSE
              CALL PUSHCONTROL6B(15)
            END IF
          CASE ('Cfp10') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = CFP(qo, 0.1_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = CFP(qs, 0.1_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(14)
            ELSE
              CALL PUSHCONTROL6B(13)
            END IF
          CASE ('Cfp50') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = CFP(qo, 0.5_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = CFP(qs, 0.5_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(12)
            ELSE
              CALL PUSHCONTROL6B(11)
            END IF
          CASE ('Cfp90') 
            CALL PUSHREAL4(jobs_tmp)
            jobs_tmp = CFP(qo, 0.9_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              CALL PUSHREAL4(result1)
              result1 = CFP(qs, 0.9_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
              CALL PUSHCONTROL6B(10)
            ELSE
              CALL PUSHCONTROL6B(9)
            END IF
          CASE ('Erc') 
! Event Signatures
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = RC(mprcp(range_event(1):range_event(2)), qo(&
&                 range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = RC(mprcp(range_event(1):range_event(2)), qs(&
&                   range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(8)
          CASE ('Erchf') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = RCHF(mprcp(range_event(1):range_event(2)), qo&
&                 (range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = RCHF(mprcp(range_event(1):range_event(2)), &
&                   qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(7)
          CASE ('Erclf') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = RCLF(mprcp(range_event(1):range_event(2)), qo&
&                 (range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = RCLF(mprcp(range_event(1):range_event(2)), &
&                   qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(6)
          CASE ('Erch2r') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = RCH2R(mprcp(range_event(1):range_event(2)), &
&                 qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = RCH2R(mprcp(range_event(1):range_event(2)), &
&                   qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(5)
          CASE ('Eff') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = EFF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = EFF(qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(4)
          CASE ('Ebf') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = EBF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = EBF(qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(3)
          CASE ('Elt') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = ELT(mprcp(range_event(1):range_event(2)), qo(&
&                 range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = ELT(mprcp(range_event(1):range_event(2)), qs&
&                   (range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(2)
          CASE ('Epf') 
            CALL PUSHINTEGER4(n_computed_event)
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              CALL PUSHINTEGER4ARRAY(range_event, 2)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .LT. 1) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREAL4(jobs_tmp)
                jobs_tmp = EPF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  CALL PUSHREAL4(result1)
                  result1 = EPF(qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                  CALL PUSHCONTROL2B(2)
                ELSE
                  CALL PUSHCONTROL2B(1)
                END IF
              END IF
            END DO
            CALL PUSHINTEGER4(k - 1)
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
            CALL PUSHCONTROL6B(1)
          CASE DEFAULT
            CALL PUSHCONTROL6B(0)
          END SELECT
        END DO
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
! TODO TH: handle with alias (median, low/upp quartiles) for jobs_cmpt
    IF (ANY(options%cost%wgauge(:) .LT. 0._sp)) THEN
      jobs_gauge = 0._sp
      k = 0
      DO i=1,mesh%ng
        IF (options%cost%wgauge(i) .GE. 0.) THEN
          abs1 = options%cost%wgauge(i)
        ELSE
          abs1 = -options%cost%wgauge(i)
        END IF
        IF (abs1 .LE. 0._sp) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL4(jobs_tmp)
          jobs_tmp = 0._sp
          DO j=1,options%cost%njoc
            jobs_tmp = jobs_tmp + options%cost%wjobs_cmpt(j)*&
&             jobs_cmpt_values(i, j)
          END DO
          CALL PUSHINTEGER4(k)
          k = k + 1
          jobs_gauge(k) = jobs_tmp
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
      IF (options%cost%wgauge(1) .GE. 0.) THEN
        abs2 = options%cost%wgauge(1)
      ELSE
        abs2 = -options%cost%wgauge(1)
      END IF
      res = QUANTILE1D_R(jobs_gauge(1:k), abs2)
      jobs_gauge_b = 0.0_4
      res_b = jobs_b
      CALL QUANTILE1D_R_B(jobs_gauge(1:k), jobs_gauge_b(1:k), abs2, &
&                   res_b)
      jobs_cmpt_values_b = 0.0_4
      DO i=mesh%ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          jobs_tmp_b = jobs_gauge_b(k)
          jobs_gauge_b(k) = 0.0_4
          CALL POPINTEGER4(k)
          DO j=options%cost%njoc,1,-1
            jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j) + &
&             options%cost%wjobs_cmpt(j)*jobs_tmp_b
          END DO
          CALL POPREAL4(jobs_tmp)
        END IF
      END DO
    ELSE
      jobs_cmpt_values_b = 0.0_4
      DO i=mesh%ng,1,-1
        DO j=options%cost%njoc,1,-1
          jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j) + options%&
&           cost%wgauge(i)*options%cost%wjobs_cmpt(j)*jobs_b
        END DO
      END DO
    END IF
    output_b%sim_response%q = 0.0_4
    DO i=mesh%ng,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        qs_b = 0.0_4
        DO 140 j=options%cost%njoc,1,-1
          CALL POPCONTROL6B(branch)
          IF (branch .LT. 16) THEN
            IF (branch .LT. 8) THEN
              IF (branch .LT. 4) THEN
                IF (branch .LT. 2) THEN
                  IF (branch .NE. 0) THEN
                    jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                     n_computed_event
                    CALL POPINTEGER4(ad_to6)
                    DO k=ad_to6,1,-1
                      CALL POPCONTROL2B(branch)
                      IF (branch .NE. 0) THEN
                        IF (branch .NE. 1) THEN
                          result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                           jobs_cmpt_values_b(i, j)/jobs_tmp
                          CALL POPREAL4(result1)
                          CALL EPF_B(qs(range_event(1):range_event(2)), &
&                              qs_b(range_event(1):range_event(2)), &
&                              result1_b)
                        END IF
                        CALL POPREAL4(jobs_tmp)
                      END IF
                      CALL POPINTEGER4ARRAY(range_event, 2)
                    END DO
                    CALL POPINTEGER4(n_computed_event)
                  END IF
                ELSE IF (branch .EQ. 2) THEN
                  jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                   n_computed_event
                  CALL POPINTEGER4(ad_to5)
                  DO k=ad_to5,1,-1
                    CALL POPCONTROL2B(branch)
                    IF (branch .NE. 0) THEN
                      IF (branch .NE. 1) CALL POPREAL4(result1)
                      CALL POPREAL4(jobs_tmp)
                    END IF
                    CALL POPINTEGER4ARRAY(range_event, 2)
                  END DO
                  CALL POPINTEGER4(n_computed_event)
                ELSE
                  jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                   n_computed_event
                  CALL POPINTEGER4(ad_to4)
                  DO k=ad_to4,1,-1
                    CALL POPCONTROL2B(branch)
                    IF (branch .NE. 0) THEN
                      IF (branch .NE. 1) THEN
                        result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                         jobs_cmpt_values_b(i, j)/jobs_tmp
                        CALL POPREAL4(result1)
                        CALL EBF_B(qs(range_event(1):range_event(2)), &
&                            qs_b(range_event(1):range_event(2)), &
&                            result1_b)
                      END IF
                      CALL POPREAL4(jobs_tmp)
                    END IF
                    CALL POPINTEGER4ARRAY(range_event, 2)
                  END DO
                  CALL POPINTEGER4(n_computed_event)
                END IF
              ELSE IF (branch .LT. 6) THEN
                IF (branch .EQ. 4) THEN
                  jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                   n_computed_event
                  CALL POPINTEGER4(ad_to3)
                  DO k=ad_to3,1,-1
                    CALL POPCONTROL2B(branch)
                    IF (branch .NE. 0) THEN
                      IF (branch .NE. 1) THEN
                        result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                         jobs_cmpt_values_b(i, j)/jobs_tmp
                        CALL POPREAL4(result1)
                        CALL EFF_B(qs(range_event(1):range_event(2)), &
&                            qs_b(range_event(1):range_event(2)), &
&                            result1_b)
                      END IF
                      CALL POPREAL4(jobs_tmp)
                    END IF
                    CALL POPINTEGER4ARRAY(range_event, 2)
                  END DO
                  CALL POPINTEGER4(n_computed_event)
                ELSE
                  jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                   n_computed_event
                  CALL POPINTEGER4(ad_to2)
                  DO k=ad_to2,1,-1
                    CALL POPCONTROL2B(branch)
                    IF (branch .NE. 0) THEN
                      IF (branch .NE. 1) THEN
                        result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                         jobs_cmpt_values_b(i, j)/jobs_tmp
                        CALL POPREAL4(result1)
                        CALL RCH2R_B(mprcp(range_event(1):range_event(2)&
&                              ), qs(range_event(1):range_event(2)), &
&                              qs_b(range_event(1):range_event(2)), &
&                              result1_b)
                      END IF
                      CALL POPREAL4(jobs_tmp)
                    END IF
                    CALL POPINTEGER4ARRAY(range_event, 2)
                  END DO
                  CALL POPINTEGER4(n_computed_event)
                END IF
              ELSE IF (branch .EQ. 6) THEN
                jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                 n_computed_event
                CALL POPINTEGER4(ad_to1)
                DO k=ad_to1,1,-1
                  CALL POPCONTROL2B(branch)
                  IF (branch .NE. 0) THEN
                    IF (branch .NE. 1) THEN
                      result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                       jobs_cmpt_values_b(i, j)/jobs_tmp
                      CALL POPREAL4(result1)
                      CALL RCLF_B(mprcp(range_event(1):range_event(2)), &
&                           qs(range_event(1):range_event(2)), qs_b(&
&                           range_event(1):range_event(2)), result1_b)
                    END IF
                    CALL POPREAL4(jobs_tmp)
                  END IF
                  CALL POPINTEGER4ARRAY(range_event, 2)
                END DO
                CALL POPINTEGER4(n_computed_event)
              ELSE
                jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                 n_computed_event
                CALL POPINTEGER4(ad_to0)
                DO k=ad_to0,1,-1
                  CALL POPCONTROL2B(branch)
                  IF (branch .NE. 0) THEN
                    IF (branch .NE. 1) THEN
                      result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                       jobs_cmpt_values_b(i, j)/jobs_tmp
                      CALL POPREAL4(result1)
                      CALL RCHF_B(mprcp(range_event(1):range_event(2)), &
&                           qs(range_event(1):range_event(2)), qs_b(&
&                           range_event(1):range_event(2)), result1_b)
                    END IF
                    CALL POPREAL4(jobs_tmp)
                  END IF
                  CALL POPINTEGER4ARRAY(range_event, 2)
                END DO
                CALL POPINTEGER4(n_computed_event)
              END IF
            ELSE
              IF (branch .LT. 12) THEN
                IF (branch .LT. 10) THEN
                  IF (branch .EQ. 8) THEN
                    jobs_cmpt_values_b(i, j) = jobs_cmpt_values_b(i, j)/&
&                     n_computed_event
                    CALL POPINTEGER4(ad_to)
                    DO k=ad_to,1,-1
                      CALL POPCONTROL2B(branch)
                      IF (branch .NE. 0) THEN
                        IF (branch .NE. 1) THEN
                          result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                           jobs_cmpt_values_b(i, j)/jobs_tmp
                          CALL POPREAL4(result1)
                          CALL RC_B(mprcp(range_event(1):range_event(2))&
&                             , qs(range_event(1):range_event(2)), qs_b(&
&                             range_event(1):range_event(2)), result1_b)
                        END IF
                        CALL POPREAL4(jobs_tmp)
                      END IF
                      CALL POPINTEGER4ARRAY(range_event, 2)
                    END DO
                    CALL POPINTEGER4(n_computed_event)
                    GOTO 140
                  END IF
                ELSE IF (branch .EQ. 10) THEN
                  result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                   jobs_cmpt_values_b(i, j)/jobs_tmp
                  jobs_cmpt_values_b(i, j) = 0.0_4
                  CALL POPREAL4(result1)
                  CALL CFP_B(qs, qs_b, 0.9_sp, result1_b)
                ELSE
                  GOTO 100
                END IF
                CALL POPREAL4(jobs_tmp)
              ELSE
                IF (branch .LT. 14) THEN
                  IF (branch .EQ. 12) THEN
                    result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                     jobs_cmpt_values_b(i, j)/jobs_tmp
                    jobs_cmpt_values_b(i, j) = 0.0_4
                    CALL POPREAL4(result1)
                    CALL CFP_B(qs, qs_b, 0.5_sp, result1_b)
                    GOTO 100
                  END IF
                ELSE IF (branch .EQ. 14) THEN
                  result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                   jobs_cmpt_values_b(i, j)/jobs_tmp
                  jobs_cmpt_values_b(i, j) = 0.0_4
                  CALL POPREAL4(result1)
                  CALL CFP_B(qs, qs_b, 0.1_sp, result1_b)
                ELSE
                  GOTO 130
                END IF
                CALL POPREAL4(jobs_tmp)
              END IF
              GOTO 140
 100          CALL POPREAL4(jobs_tmp)
            END IF
          ELSE
            IF (branch .LT. 24) THEN
              IF (branch .LT. 20) THEN
                IF (branch .LT. 18) THEN
                  IF (branch .EQ. 16) THEN
                    result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                     jobs_cmpt_values_b(i, j)/jobs_tmp
                    jobs_cmpt_values_b(i, j) = 0.0_4
                    CALL POPREAL4(result1)
                    CALL CFP_B(qs, qs_b, 0.02_sp, result1_b)
                    GOTO 130
                  END IF
                ELSE IF (branch .EQ. 18) THEN
                  result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                   jobs_cmpt_values_b(i, j)/jobs_tmp
                  jobs_cmpt_values_b(i, j) = 0.0_4
                  CALL POPREAL4(result1)
                  CALL RCH2R_B(mprcp, qs, qs_b, result1_b)
                ELSE
                  GOTO 110
                END IF
                CALL POPREAL4(jobs_tmp)
              ELSE
                IF (branch .LT. 22) THEN
                  IF (branch .EQ. 20) THEN
                    result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                     jobs_cmpt_values_b(i, j)/jobs_tmp
                    jobs_cmpt_values_b(i, j) = 0.0_4
                    CALL POPREAL4(result1)
                    CALL RCLF_B(mprcp, qs, qs_b, result1_b)
                    GOTO 110
                  END IF
                ELSE IF (branch .EQ. 22) THEN
                  result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                   jobs_cmpt_values_b(i, j)/jobs_tmp
                  jobs_cmpt_values_b(i, j) = 0.0_4
                  CALL POPREAL4(result1)
                  CALL RCHF_B(mprcp, qs, qs_b, result1_b)
                ELSE
                  GOTO 120
                END IF
                CALL POPREAL4(jobs_tmp)
              END IF
              GOTO 140
 110          CALL POPREAL4(jobs_tmp)
              GOTO 140
            ELSE IF (branch .LT. 28) THEN
              IF (branch .LT. 26) THEN
                IF (branch .EQ. 24) THEN
                  result1_b = 2*(result1/jobs_tmp-1._sp)*&
&                   jobs_cmpt_values_b(i, j)/jobs_tmp
                  jobs_cmpt_values_b(i, j) = 0.0_4
                  CALL POPREAL4(result1)
                  CALL RC_B(mprcp, qs, qs_b, result1_b)
                ELSE
                  CALL LGRM_B(qo, qs, qs_b, jobs_cmpt_values_b(i, j))
                  jobs_cmpt_values_b(i, j) = 0.0_4
                  GOTO 140
                END IF
              ELSE
                IF (branch .EQ. 26) THEN
                  CALL RMSE_B(qo, qs, qs_b, jobs_cmpt_values_b(i, j))
                  jobs_cmpt_values_b(i, j) = 0.0_4
                ELSE
                  CALL MSE_B(qo, qs, qs_b, jobs_cmpt_values_b(i, j))
                  jobs_cmpt_values_b(i, j) = 0.0_4
                END IF
                GOTO 140
              END IF
            ELSE
              IF (branch .LT. 30) THEN
                IF (branch .EQ. 28) THEN
                  CALL MAPE_B(qo, qs, qs_b, jobs_cmpt_values_b(i, j))
                  jobs_cmpt_values_b(i, j) = 0.0_4
                ELSE
                  CALL MAE_B(qo, qs, qs_b, jobs_cmpt_values_b(i, j))
                  jobs_cmpt_values_b(i, j) = 0.0_4
                END IF
              ELSE IF (branch .EQ. 30) THEN
                result1_b = -jobs_cmpt_values_b(i, j)
                jobs_cmpt_values_b(i, j) = 0.0_4
                CALL POPREAL4(result1)
                CALL KGE_B(qo, qs, qs_b, result1_b)
              ELSE IF (branch .EQ. 31) THEN
                result1_b = -jobs_cmpt_values_b(i, j)
                jobs_cmpt_values_b(i, j) = 0.0_4
                CALL POPREAL4(result1)
                CALL NNSE_B(qo, qs, qs_b, result1_b)
              ELSE
                result1_b = -jobs_cmpt_values_b(i, j)
                jobs_cmpt_values_b(i, j) = 0.0_4
                CALL POPREAL4(result1)
                CALL NSE_B(qo, qs, qs_b, result1_b)
              END IF
              GOTO 140
            END IF
 120        CALL POPREAL4(jobs_tmp)
          END IF
          GOTO 140
 130      CALL POPREAL4(jobs_tmp)
 140    CONTINUE
        WHERE (qo .LT. 0._sp) qs_b = 0.0_4
        CALL POPREAL4ARRAY(mprcp, setup%ntime_step - options%cost%&
&                    end_warmup + 1)
        CALL POPREAL4ARRAY(qs, setup%ntime_step - options%cost%&
&                    end_warmup + 1)
        output_b%sim_response%q(i, options%cost%end_warmup:setup%&
&       ntime_step) = output_b%sim_response%q(i, options%cost%end_warmup&
&         :setup%ntime_step) + qs_b
        CALL POPREAL4ARRAY(qo, setup%ntime_step - options%cost%&
&                    end_warmup + 1)
      END IF
    END DO
  END SUBROUTINE CLS_COMPUTE_JOBS_B

  SUBROUTINE CLS_COMPUTE_JOBS(setup, mesh, input_data, output, options, &
&   returns, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(IN) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    REAL(sp), INTENT(INOUT) :: jobs
    INTEGER :: i, j, k, n_computed_event
    REAL(sp), DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   qo, qs, mprcp
    INTEGER, DIMENSION(setup%ntime_step-options%cost%end_warmup+1) :: &
&   mask_event
    REAL(sp), DIMENSION(mesh%ng, options%cost%njoc) :: jobs_cmpt_values
    INTEGER, DIMENSION(2) :: range_event
    REAL(sp), DIMENSION(mesh%ng) :: jobs_gauge
    REAL(sp) :: jobs_tmp
    INTRINSIC ABS
    INTRINSIC ANY
    REAL(sp) :: abs0
    REAL(sp) :: abs1
    REAL(sp) :: abs2
    REAL(sp) :: result1
    jobs_cmpt_values = 0._sp
    DO i=1,mesh%ng
      IF (options%cost%wgauge(i) .GE. 0.) THEN
        abs0 = options%cost%wgauge(i)
      ELSE
        abs0 = -options%cost%wgauge(i)
      END IF
! Cycle if wgauge is equal to 0
      IF (abs0 .GT. 0._sp) THEN
        qo = input_data%obs_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        qs = output%sim_response%q(i, options%cost%end_warmup:setup%&
&         ntime_step)
        WHERE (qo .LT. 0._sp) qs = -99._sp
! Convert mean_prcp from mm/dt to m3/s
        mprcp = input_data%atmos_data%mean_prcp(i, options%cost%&
&         end_warmup:setup%ntime_step)*mesh%area_dln(i)*1.e-3_sp/setup%&
&         dt
        mask_event = options%cost%mask_event(i, options%cost%end_warmup:&
&         setup%ntime_step)
        DO j=1,options%cost%njoc
! Should be unreachable.
          SELECT CASE  (options%cost%jobs_cmpt(j)) 
          CASE ('nse') 
! Efficiency Metrics
            result1 = NSE(qo, qs)
            jobs_cmpt_values(i, j) = 1._sp - result1
          CASE ('nnse') 
            result1 = NNSE(qo, qs)
            jobs_cmpt_values(i, j) = 1._sp - result1
          CASE ('kge') 
            result1 = KGE(qo, qs)
            jobs_cmpt_values(i, j) = 1._sp - result1
          CASE ('mae') 
            jobs_cmpt_values(i, j) = MAE(qo, qs)
          CASE ('mape') 
            jobs_cmpt_values(i, j) = MAPE(qo, qs)
          CASE ('mse') 
            jobs_cmpt_values(i, j) = MSE(qo, qs)
          CASE ('rmse') 
            jobs_cmpt_values(i, j) = RMSE(qo, qs)
          CASE ('lgrm') 
            jobs_cmpt_values(i, j) = LGRM(qo, qs)
          CASE ('Crc') 
! Continuous Signatures
            jobs_tmp = RC(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = RC(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Crchf') 
            jobs_tmp = RCHF(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = RCHF(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Crclf') 
            jobs_tmp = RCLF(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = RCLF(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Crch2r') 
            jobs_tmp = RCH2R(mprcp, qo)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = RCH2R(mprcp, qs)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp2') 
            jobs_tmp = CFP(qo, 0.02_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = CFP(qs, 0.02_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp10') 
            jobs_tmp = CFP(qo, 0.1_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = CFP(qs, 0.1_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp50') 
            jobs_tmp = CFP(qo, 0.5_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = CFP(qs, 0.5_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Cfp90') 
            jobs_tmp = CFP(qo, 0.9_sp)
            IF (jobs_tmp .GT. 0._sp) THEN
              result1 = CFP(qs, 0.9_sp)
              jobs_cmpt_values(i, j) = (result1/jobs_tmp-1._sp)**2
            END IF
          CASE ('Erc') 
! Event Signatures
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RC(mprcp(range_event(1):range_event(2)), qo(&
&                 range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = RC(mprcp(range_event(1):range_event(2)), qs(&
&                   range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Erchf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RCHF(mprcp(range_event(1):range_event(2)), qo&
&                 (range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = RCHF(mprcp(range_event(1):range_event(2)), &
&                   qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Erclf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RCLF(mprcp(range_event(1):range_event(2)), qo&
&                 (range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = RCLF(mprcp(range_event(1):range_event(2)), &
&                   qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Erch2r') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = RCH2R(mprcp(range_event(1):range_event(2)), &
&                 qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = RCH2R(mprcp(range_event(1):range_event(2)), &
&                   qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Eff') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = EFF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = EFF(qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Ebf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = EBF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = EBF(qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Elt') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = ELT(mprcp(range_event(1):range_event(2)), qo(&
&                 range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = ELT(mprcp(range_event(1):range_event(2)), qs&
&                   (range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          CASE ('Epf') 
            n_computed_event = 0
            DO k=1,options%cost%n_event(i)
              range_event = GET_RANGE_EVENT(mask_event, k)
              IF (range_event(1) .GE. 1) THEN
                jobs_tmp = EPF(qo(range_event(1):range_event(2)))
                IF (jobs_tmp .GT. 0._sp) THEN
                  result1 = EPF(qs(range_event(1):range_event(2)))
                  jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j) + (&
&                   result1/jobs_tmp-1._sp)**2
                  n_computed_event = n_computed_event + 1
                END IF
              END IF
            END DO
            jobs_cmpt_values(i, j) = jobs_cmpt_values(i, j)/&
&             n_computed_event
          END SELECT
        END DO
      END IF
    END DO
! TODO TH: handle with alias (median, low/upp quartiles) for jobs_cmpt
    IF (ANY(options%cost%wgauge(:) .LT. 0._sp)) THEN
      jobs_gauge = 0._sp
      k = 0
      DO i=1,mesh%ng
        IF (options%cost%wgauge(i) .GE. 0.) THEN
          abs1 = options%cost%wgauge(i)
        ELSE
          abs1 = -options%cost%wgauge(i)
        END IF
        IF (abs1 .GT. 0._sp) THEN
          jobs_tmp = 0._sp
          DO j=1,options%cost%njoc
            jobs_tmp = jobs_tmp + options%cost%wjobs_cmpt(j)*&
&             jobs_cmpt_values(i, j)
          END DO
          k = k + 1
          jobs_gauge(k) = jobs_tmp
        END IF
      END DO
      IF (options%cost%wgauge(1) .GE. 0.) THEN
        abs2 = options%cost%wgauge(1)
      ELSE
        abs2 = -options%cost%wgauge(1)
      END IF
      jobs = QUANTILE1D_R(jobs_gauge(1:k), abs2)
    ELSE
      jobs = 0._sp
      DO i=1,mesh%ng
        DO j=1,options%cost%njoc
          jobs = jobs + options%cost%wgauge(i)*options%cost%wjobs_cmpt(j&
&           )*jobs_cmpt_values(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE CLS_COMPUTE_JOBS

!  Differentiation of cls_compute_cost in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: output.cost
!   with respect to varying inputs: *(output.sim_response.q)
!   Plus diff mem management of: output.sim_response.q:in
  SUBROUTINE CLS_COMPUTE_COST_D(setup, mesh, input_data, parameters, &
&   output, output_d, options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_d
    CALL CLS_COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, &
&                     options, returns, jobs, jobs_d)
! TODO FC: Not Implemented yet
! call cls_compute_jreg(setup, mesh, parameters, options, returns, jreg)
    output_d%cost = jobs_d
  END SUBROUTINE CLS_COMPUTE_COST_D

!  Differentiation of cls_compute_cost in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: output.cost
!   with respect to varying inputs: *(output.sim_response.q)
!   Plus diff mem management of: output.sim_response.q:in
  SUBROUTINE CLS_COMPUTE_COST_B(setup, mesh, input_data, parameters, &
&   output, output_b, options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_b
    CALL CLS_COMPUTE_JOBS(setup, mesh, input_data, output, options, &
&                   returns, jobs)
! TODO FC: Not Implemented yet
! call cls_compute_jreg(setup, mesh, parameters, options, returns, jreg)
    jobs_b = output_b%cost
    CALL CLS_COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, &
&                     options, returns, jobs, jobs_b)
  END SUBROUTINE CLS_COMPUTE_COST_B

  SUBROUTINE CLS_COMPUTE_COST(setup, mesh, input_data, parameters, &
&   output, options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    REAL(sp) :: jobs, jreg
    jobs = 0._sp
    jreg = 0._sp
    CALL CLS_COMPUTE_JOBS(setup, mesh, input_data, output, options, &
&                   returns, jobs)
! TODO FC: Not Implemented yet
! call cls_compute_jreg(setup, mesh, parameters, options, returns, jreg)
    output%cost = jobs + options%cost%wjreg*jreg
  END SUBROUTINE CLS_COMPUTE_COST

!  Differentiation of compute_cost in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: output.cost
!   with respect to varying inputs: *(output.sim_response.q)
!   Plus diff mem management of: output.sim_response.q:in
  SUBROUTINE COMPUTE_COST_D(setup, mesh, input_data, parameters, output&
&   , output_d, options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
! TODO BR: Not Implemented Yet
    SELECT CASE  (options%cost%variant) 
    CASE ('cls') 
      CALL CLS_COMPUTE_COST_D(setup, mesh, input_data, parameters, &
&                       output, output_d, options, returns)
    CASE ('bys') 
      output_d%cost = 0.0_4
    CASE DEFAULT
      output_d%cost = 0.0_4
    END SELECT
  END SUBROUTINE COMPUTE_COST_D

!  Differentiation of compute_cost in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: output.cost
!   with respect to varying inputs: *(output.sim_response.q)
!   Plus diff mem management of: output.sim_response.q:in
  SUBROUTINE COMPUTE_COST_B(setup, mesh, input_data, parameters, output&
&   , output_b, options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
! TODO BR: Not Implemented Yet
    SELECT CASE  (options%cost%variant) 
    CASE ('cls') 
      CALL CLS_COMPUTE_COST(setup, mesh, input_data, parameters, output&
&                     , options, returns)
      CALL CLS_COMPUTE_COST_B(setup, mesh, input_data, parameters, &
&                       output, output_b, options, returns)
    CASE DEFAULT
      output_b%sim_response%q = 0.0_4
    END SELECT
  END SUBROUTINE COMPUTE_COST_B

  SUBROUTINE COMPUTE_COST(setup, mesh, input_data, parameters, output, &
&   options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
! TODO BR: Not Implemented Yet
    SELECT CASE  (options%cost%variant) 
    CASE ('cls') 
      CALL CLS_COMPUTE_COST(setup, mesh, input_data, parameters, output&
&                     , options, returns)
    CASE ('bys') 

    END SELECT
  END SUBROUTINE COMPUTE_COST

END MODULE MWD_COST_DIFF

!%      (MWD) Module Wrapped and Differentiated
!%
!%      Subroutine
!%      ----------
!%
!%      - uniform_get_control_size
!%      - distributed_get_control_size
!%      - multi_linear_get_control_size
!%      - multi_polynomial_get_control_size
!%      - sigmoide
!%      - inv_sigmoide
!%      - scaled_sigmoide
!%      - inv_scaled_sigmoid
!%      - sigmoide2d
!%      - scaled_sigmoide2d
!%      - sbs_control_tfm
!%      - sbs_inv_control_tfm
!%      - normalize_control_tfm
!%      - normalize_inv_control_tfm
!%      - uniform_parameters_to_control
!%      - uniform_control_to_parameters
!%      - distributed_parameters_to_control
!%      - distributed_control_to_parameters
!%      - multi_linear_parameters_to_control
!%      - multi_linear_control_to_parameters
!%      - multi_polynomial_parameters_to_control
!%      - multi_polynomial_control_to_parameters
!%      - control_tfm
!%      - inv_control_tfm
!%      - parameters_to_control
!%      - control_to_parameters
MODULE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ControlDT_initialise, ControlDT_finalise
  USE MWD_CONTROL_DIFF
  IMPLICIT NONE
  PUBLIC :: parameters_to_control, control_to_parameters
  PUBLIC :: control_to_parameters_d, control_to_parameters_b

CONTAINS
  SUBROUTINE UNIFORM_GET_CONTROL_SIZE(setup, options, n)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER, INTENT(INOUT) :: n
    INTRINSIC SUM
    n = SUM(options%optimize%opr_parameters) + SUM(options%optimize%&
&     opr_initial_states)
  END SUBROUTINE UNIFORM_GET_CONTROL_SIZE

  SUBROUTINE DISTRIBUTED_GET_CONTROL_SIZE(setup, mesh, options, n)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER, INTENT(INOUT) :: n
    INTRINSIC SUM
    n = (SUM(options%optimize%opr_parameters)+SUM(options%optimize%&
&     opr_initial_states))*mesh%nac
  END SUBROUTINE DISTRIBUTED_GET_CONTROL_SIZE

  SUBROUTINE MULTI_LINEAR_GET_CONTROL_SIZE(setup, options, n)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER, INTENT(INOUT) :: n
    INTEGER :: i
    INTRINSIC SUM
    n = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) n = n + 1 + SUM(&
&         options%optimize%opr_parameters_descriptor(:, i))
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) n = n + 1 + SUM&
&         (options%optimize%opr_initial_states_descriptor(:, i))
    END DO
  END SUBROUTINE MULTI_LINEAR_GET_CONTROL_SIZE

  SUBROUTINE MULTI_POLYNOMIAL_GET_CONTROL_SIZE(setup, options, n)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER, INTENT(INOUT) :: n
    INTEGER :: i
    INTRINSIC SUM
    n = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) n = n + 1 + 2*SUM(&
&         options%optimize%opr_parameters_descriptor(:, i))
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) n = n + 1 + 2*&
&         SUM(options%optimize%opr_initial_states_descriptor(:, i))
    END DO
  END SUBROUTINE MULTI_POLYNOMIAL_GET_CONTROL_SIZE

  SUBROUTINE SIGMOIDE(x, res)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: x
    REAL(sp), INTENT(INOUT) :: res
    INTRINSIC EXP
    res = 1._sp/(1._sp+EXP(-x))
  END SUBROUTINE SIGMOIDE

  SUBROUTINE INV_SIGMOIDE(x, res)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: x
    REAL(sp), INTENT(INOUT) :: res
    INTRINSIC LOG
    res = LOG(x/(1._sp-x))
  END SUBROUTINE INV_SIGMOIDE

  SUBROUTINE SCALED_SIGMOIDE(x, l, u, res)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: x, l, u
    REAL(sp), INTENT(INOUT) :: res
    CALL SIGMOIDE(x, res)
    res = res*(u-l) + l
  END SUBROUTINE SCALED_SIGMOIDE

  SUBROUTINE INV_SCALED_SIGMOID(x, l, u, res)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: x, l, u
    REAL(sp), INTENT(INOUT) :: res
    REAL(sp) :: xw
    REAL(sp), SAVE :: eps=1e-3_sp
    INTRINSIC MAX
    INTRINSIC MIN
    IF (x .LT. l + eps) THEN
      xw = l + eps
    ELSE
      xw = x
    END IF
    IF (x .GT. u - eps) THEN
      xw = u - eps
    ELSE
      xw = x
    END IF
    xw = (xw-l)/(u-l)
    CALL INV_SIGMOIDE(xw, res)
  END SUBROUTINE INV_SCALED_SIGMOID

!  Differentiation of sigmoide2d in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: x
  SUBROUTINE SIGMOIDE2D_D(x, x_d, res, res_d)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x_d
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res_d
    INTRINSIC EXP
    REAL*4, DIMENSION(SIZE(x, 1), SIZE(x, 2)) :: temp
    temp = 1.0/(EXP(-x)+1._sp)
    res_d = temp*EXP(-x)*x_d/(EXP(-x)+1._sp)
    res = temp
  END SUBROUTINE SIGMOIDE2D_D

!  Differentiation of sigmoide2d in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res
!   with respect to varying inputs: x
  SUBROUTINE SIGMOIDE2D_B(x, x_b, res, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x
    REAL(sp), DIMENSION(:, :) :: x_b
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res_b
    INTRINSIC EXP
    REAL(sp), DIMENSION(SIZE(x, 1), SIZE(x, 2)) :: temp
    x_b = 0.0_4
    temp = EXP(-x) + 1._sp
    x_b = EXP(-x)*res_b/temp**2
  END SUBROUTINE SIGMOIDE2D_B

  SUBROUTINE SIGMOIDE2D(x, res)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res
    INTRINSIC EXP
    res = 1._sp/(1._sp+EXP(-x))
  END SUBROUTINE SIGMOIDE2D

!  Differentiation of scaled_sigmoide2d in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: res
!   with respect to varying inputs: x
  SUBROUTINE SCALED_SIGMOIDE2D_D(x, x_d, l, u, res, res_d)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x_d
    REAL(sp), INTENT(IN) :: l, u
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res_d
    CALL SIGMOIDE2D_D(x, x_d, res, res_d)
    res_d = (u-l)*res_d
    res = res*(u-l) + l
  END SUBROUTINE SCALED_SIGMOIDE2D_D

!  Differentiation of scaled_sigmoide2d in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: res
!   with respect to varying inputs: x
  SUBROUTINE SCALED_SIGMOIDE2D_B(x, x_b, l, u, res, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x
    REAL(sp), DIMENSION(:, :) :: x_b
    REAL(sp), INTENT(IN) :: l, u
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res_b
    CALL SIGMOIDE2D(x, res)
    res_b = (u-l)*res_b
    CALL SIGMOIDE2D_B(x, x_b, res, res_b)
  END SUBROUTINE SCALED_SIGMOIDE2D_B

  SUBROUTINE SCALED_SIGMOIDE2D(x, l, u, res)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:, :), INTENT(IN) :: x
    REAL(sp), INTENT(IN) :: l, u
    REAL(sp), DIMENSION(:, :), INTENT(INOUT) :: res
    CALL SIGMOIDE2D(x, res)
    res = res*(u-l) + l
  END SUBROUTINE SCALED_SIGMOIDE2D

  SUBROUTINE SBS_CONTROL_TFM(parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: i
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
    INTRINSIC ASINH
    INTRINSIC LOG
!% Need lower and upper bound to sbs tfm
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    DO i=1,SIZE(parameters%control%x)
      IF (nbd_mask(i)) THEN
        IF (parameters%control%l_bkg(i) .LT. 0._sp) THEN
          parameters%control%x(i) = ASINH(parameters%control%x(i))
          parameters%control%l(i) = ASINH(parameters%control%l_bkg(i))
          parameters%control%u(i) = ASINH(parameters%control%u_bkg(i))
        ELSE IF (parameters%control%l_bkg(i) .GE. 0._sp .AND. parameters&
&           %control%u_bkg(i) .LE. 1._sp) THEN
          parameters%control%x(i) = LOG(parameters%control%x(i)/(1._sp-&
&           parameters%control%x(i)))
          parameters%control%l(i) = LOG(parameters%control%l_bkg(i)/(&
&           1._sp-parameters%control%l_bkg(i)))
          parameters%control%u(i) = LOG(parameters%control%u_bkg(i)/(&
&           1._sp-parameters%control%u_bkg(i)))
        ELSE
          parameters%control%x(i) = LOG(parameters%control%x(i))
          parameters%control%l(i) = LOG(parameters%control%l_bkg(i))
          parameters%control%u(i) = LOG(parameters%control%u_bkg(i))
        END IF
      END IF
    END DO
  END SUBROUTINE SBS_CONTROL_TFM

!  Differentiation of sbs_inv_control_tfm in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(parameters.control.x)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in
  SUBROUTINE SBS_INV_CONTROL_TFM_D(parameters, parameters_d)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    INTEGER :: i
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
    INTRINSIC SINH
    INTRINSIC EXP
    REAL(sp) :: temp
    REAL(sp) :: temp0
!% Need lower and upper bound to sbs tfm
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    DO i=1,SIZE(parameters%control%x)
      IF (nbd_mask(i)) THEN
        IF (parameters%control%l_bkg(i) .LT. 0._sp) THEN
          parameters_d%control%x(i) = COSH(parameters%control%x(i))*&
&           parameters_d%control%x(i)
          parameters%control%x(i) = SINH(parameters%control%x(i))
        ELSE IF (parameters%control%l_bkg(i) .GE. 0._sp .AND. parameters&
&           %control%u_bkg(i) .LE. 1._sp) THEN
          temp = EXP(parameters%control%x(i)) + 1._sp
          temp0 = EXP(parameters%control%x(i))/temp
          parameters_d%control%x(i) = (EXP(parameters%control%x(i))-&
&           temp0*EXP(parameters%control%x(i)))*parameters_d%control%x(i&
&           )/temp
          parameters%control%x(i) = temp0
        ELSE
          parameters_d%control%x(i) = EXP(parameters%control%x(i))*&
&           parameters_d%control%x(i)
          parameters%control%x(i) = EXP(parameters%control%x(i))
        END IF
      END IF
    END DO
  END SUBROUTINE SBS_INV_CONTROL_TFM_D

!  Differentiation of sbs_inv_control_tfm in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(parameters.control.x)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in
  SUBROUTINE SBS_INV_CONTROL_TFM_B(parameters, parameters_b)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    INTEGER :: i
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
    INTRINSIC SINH
    INTRINSIC EXP
    REAL(sp) :: temp
    INTEGER :: ad_to
    INTEGER :: branch
!% Need lower and upper bound to sbs tfm
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    DO i=1,SIZE(parameters%control%x)
      IF (.NOT.nbd_mask(i)) THEN
        CALL PUSHCONTROL2B(0)
      ELSE IF (parameters%control%l_bkg(i) .LT. 0._sp) THEN
        CALL PUSHREAL4(parameters%control%x(i))
        parameters%control%x(i) = SINH(parameters%control%x(i))
        CALL PUSHCONTROL2B(3)
      ELSE IF (parameters%control%l_bkg(i) .GE. 0._sp .AND. parameters%&
&         control%u_bkg(i) .LE. 1._sp) THEN
        CALL PUSHREAL4(parameters%control%x(i))
        parameters%control%x(i) = EXP(parameters%control%x(i))/(1._sp+&
&         EXP(parameters%control%x(i)))
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHREAL4(parameters%control%x(i))
        parameters%control%x(i) = EXP(parameters%control%x(i))
        CALL PUSHCONTROL2B(1)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .NE. 0) THEN
          CALL POPREAL4(parameters%control%x(i))
          parameters_b%control%x(i) = EXP(parameters%control%x(i))*&
&           parameters_b%control%x(i)
        END IF
      ELSE IF (branch .EQ. 2) THEN
        CALL POPREAL4(parameters%control%x(i))
        temp = EXP(parameters%control%x(i)) + 1._sp
        parameters_b%control%x(i) = (EXP(parameters%control%x(i))/temp-&
&         EXP(parameters%control%x(i))**2/temp**2)*parameters_b%control%&
&         x(i)
      ELSE
        CALL POPREAL4(parameters%control%x(i))
        parameters_b%control%x(i) = COSH(parameters%control%x(i))*&
&         parameters_b%control%x(i)
      END IF
    END DO
  END SUBROUTINE SBS_INV_CONTROL_TFM_B

  SUBROUTINE SBS_INV_CONTROL_TFM(parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: i
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
    INTRINSIC SINH
    INTRINSIC EXP
!% Need lower and upper bound to sbs tfm
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    DO i=1,SIZE(parameters%control%x)
      IF (nbd_mask(i)) THEN
        IF (parameters%control%l_bkg(i) .LT. 0._sp) THEN
          parameters%control%x(i) = SINH(parameters%control%x(i))
        ELSE IF (parameters%control%l_bkg(i) .GE. 0._sp .AND. parameters&
&           %control%u_bkg(i) .LE. 1._sp) THEN
          parameters%control%x(i) = EXP(parameters%control%x(i))/(1._sp+&
&           EXP(parameters%control%x(i)))
        ELSE
          parameters%control%x(i) = EXP(parameters%control%x(i))
        END IF
      END IF
    END DO
    parameters%control%l = parameters%control%l_bkg
    parameters%control%u = parameters%control%u_bkg
  END SUBROUTINE SBS_INV_CONTROL_TFM

  SUBROUTINE NORMALIZE_CONTROL_TFM(parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
!% Need lower and upper bound to normalize
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    WHERE (nbd_mask) 
      parameters%control%x = (parameters%control%x-parameters%control%&
&       l_bkg)/(parameters%control%u_bkg-parameters%control%l_bkg)
      parameters%control%l = 0._sp
      parameters%control%u = 1._sp
    END WHERE
  END SUBROUTINE NORMALIZE_CONTROL_TFM

!  Differentiation of normalize_inv_control_tfm in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(parameters.control.x)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in
  SUBROUTINE NORMALIZE_INV_CONTROL_TFM_D(parameters, parameters_d)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
!% Need lower and upper bound to denormalize
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    WHERE (nbd_mask) 
      parameters_d%control%x = (parameters%control%u_bkg-parameters%&
&       control%l_bkg)*parameters_d%control%x
      parameters%control%x = parameters%control%x*(parameters%control%&
&       u_bkg-parameters%control%l_bkg) + parameters%control%l_bkg
    END WHERE
  END SUBROUTINE NORMALIZE_INV_CONTROL_TFM_D

!  Differentiation of normalize_inv_control_tfm in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(parameters.control.x)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in
  SUBROUTINE NORMALIZE_INV_CONTROL_TFM_B(parameters, parameters_b)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
!% Need lower and upper bound to denormalize
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    WHERE (nbd_mask) parameters_b%control%x = (parameters%control%u_bkg-&
&       parameters%control%l_bkg)*parameters_b%control%x
  END SUBROUTINE NORMALIZE_INV_CONTROL_TFM_B

  SUBROUTINE NORMALIZE_INV_CONTROL_TFM(parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(parameters%control%x)) :: nbd_mask
!% Need lower and upper bound to denormalize
    nbd_mask = parameters%control%nbd(:) .EQ. 2
    WHERE (nbd_mask) 
      parameters%control%x = parameters%control%x*(parameters%control%&
&       u_bkg-parameters%control%l_bkg) + parameters%control%l_bkg
      parameters%control%l = parameters%control%l_bkg
      parameters%control%u = parameters%control%u_bkg
    END WHERE
  END SUBROUTINE NORMALIZE_INV_CONTROL_TFM

  SUBROUTINE UNIFORM_PARAMETERS_TO_CONTROL(setup, mesh, parameters, &
&   options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: n, i, j
    LOGICAL, DIMENSION(mesh%nrow, mesh%ncol) :: ac_mask
    INTRINSIC SUM
    CALL UNIFORM_GET_CONTROL_SIZE(setup, options, n)
    CALL CONTROLDT_INITIALISE(parameters%control, n)
    ac_mask = mesh%active_cell(:, :) .EQ. 1
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        parameters%control%x(j) = SUM(parameters%opr_parameters%values(:&
&         , :, i), mask=ac_mask)/mesh%nac
        parameters%control%l(j) = options%optimize%l_opr_parameters(i)
        parameters%control%u(j) = options%optimize%u_opr_parameters(i)
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        parameters%control%x(j) = SUM(parameters%opr_initial_states%&
&         values(:, :, i), mask=ac_mask)/mesh%nac
        parameters%control%l(j) = options%optimize%l_opr_initial_states(&
&         i)
        parameters%control%u(j) = options%optimize%u_opr_initial_states(&
&         i)
      END IF
    END DO
!~         parameters%control%x_bkg = parameters%control%x
    parameters%control%l_bkg = parameters%control%l
    parameters%control%u_bkg = parameters%control%u
    parameters%control%nbd = 2
  END SUBROUTINE UNIFORM_PARAMETERS_TO_CONTROL

!  Differentiation of uniform_control_to_parameters in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE UNIFORM_CONTROL_TO_PARAMETERS_D(setup, mesh, parameters, &
&   parameters_d, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j
    LOGICAL, DIMENSION(mesh%nrow, mesh%ncol) :: ac_mask
    ac_mask = mesh%active_cell(:, :) .EQ. 1
    j = 0
    parameters_d%opr_parameters%values = 0.0_4
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        WHERE (ac_mask) 
          parameters_d%opr_parameters%values(:, :, i) = parameters_d%&
&           control%x(j)
          parameters%opr_parameters%values(:, :, i) = parameters%control&
&           %x(j)
        END WHERE
      END IF
    END DO
    parameters_d%opr_initial_states%values = 0.0_4
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        WHERE (ac_mask) 
          parameters_d%opr_initial_states%values(:, :, i) = parameters_d&
&           %control%x(j)
          parameters%opr_initial_states%values(:, :, i) = parameters%&
&           control%x(j)
        END WHERE
      END IF
    END DO
  END SUBROUTINE UNIFORM_CONTROL_TO_PARAMETERS_D

!  Differentiation of uniform_control_to_parameters in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE UNIFORM_CONTROL_TO_PARAMETERS_B(setup, mesh, parameters, &
&   parameters_b, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j
    LOGICAL, DIMENSION(mesh%nrow, mesh%ncol) :: ac_mask
    INTEGER :: branch
    ac_mask = mesh%active_cell(:, :) .EQ. 1
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    parameters_b%control%x = 0.0_4
    DO i=setup%nos,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&         parameters_b%opr_initial_states%values(:, :, i), MASK=ac_mask)
        CALL POPINTEGER4(j)
        WHERE (ac_mask) parameters_b%opr_initial_states%values(:, :, i)&
&          = 0.0_4
      END IF
    END DO
    DO i=setup%nop,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&         parameters_b%opr_parameters%values(:, :, i), MASK=ac_mask)
        CALL POPINTEGER4(j)
        WHERE (ac_mask) parameters_b%opr_parameters%values(:, :, i) = &
&           0.0_4
      END IF
    END DO
  END SUBROUTINE UNIFORM_CONTROL_TO_PARAMETERS_B

  SUBROUTINE UNIFORM_CONTROL_TO_PARAMETERS(setup, mesh, parameters, &
&   options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j
    LOGICAL, DIMENSION(mesh%nrow, mesh%ncol) :: ac_mask
    ac_mask = mesh%active_cell(:, :) .EQ. 1
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        WHERE (ac_mask) parameters%opr_parameters%values(:, :, i) = &
&           parameters%control%x(j)
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        WHERE (ac_mask) parameters%opr_initial_states%values(:, :, i) = &
&           parameters%control%x(j)
      END IF
    END DO
  END SUBROUTINE UNIFORM_CONTROL_TO_PARAMETERS

  SUBROUTINE DISTRIBUTED_PARAMETERS_TO_CONTROL(setup, mesh, parameters, &
&   options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: n, i, j, row, col
    CALL DISTRIBUTED_GET_CONTROL_SIZE(setup, mesh, options, n)
    CALL CONTROLDT_INITIALISE(parameters%control, n)
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .NE. 0) THEN
              j = j + 1
              parameters%control%x(j) = parameters%opr_parameters%values&
&               (row, col, i)
              parameters%control%l(j) = options%optimize%&
&               l_opr_parameters(i)
              parameters%control%u(j) = options%optimize%&
&               u_opr_parameters(i)
            END IF
          END DO
        END DO
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .NE. 0) THEN
              j = j + 1
              parameters%control%x(j) = parameters%opr_initial_states%&
&               values(row, col, i)
              parameters%control%l(j) = options%optimize%&
&               l_opr_initial_states(i)
              parameters%control%u(j) = options%optimize%&
&               u_opr_initial_states(i)
            END IF
          END DO
        END DO
      END IF
    END DO
!~         parameters%control%x_bkg = parameters%control%x
    parameters%control%l_bkg = parameters%control%l
    parameters%control%u_bkg = parameters%control%u
    parameters%control%nbd = 2
  END SUBROUTINE DISTRIBUTED_PARAMETERS_TO_CONTROL

!  Differentiation of distributed_control_to_parameters in forward (tangent) mode (with options fixinterface noISIZE OpenMP conte
!xt):
!   variations   of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE DISTRIBUTED_CONTROL_TO_PARAMETERS_D(setup, mesh, parameters&
&   , parameters_d, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, row, col
    j = 0
    parameters_d%opr_parameters%values = 0.0_4
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .NE. 0) THEN
              j = j + 1
              parameters_d%opr_parameters%values(row, col, i) = &
&               parameters_d%control%x(j)
              parameters%opr_parameters%values(row, col, i) = parameters&
&               %control%x(j)
            END IF
          END DO
        END DO
      END IF
    END DO
    parameters_d%opr_initial_states%values = 0.0_4
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .NE. 0) THEN
              j = j + 1
              parameters_d%opr_initial_states%values(row, col, i) = &
&               parameters_d%control%x(j)
              parameters%opr_initial_states%values(row, col, i) = &
&               parameters%control%x(j)
            END IF
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE DISTRIBUTED_CONTROL_TO_PARAMETERS_D

!  Differentiation of distributed_control_to_parameters in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP conte
!xt):
!   gradient     of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE DISTRIBUTED_CONTROL_TO_PARAMETERS_B(setup, mesh, parameters&
&   , parameters_b, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, row, col
    INTEGER :: branch
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .EQ. 0) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(j)
              j = j + 1
              CALL PUSHCONTROL1B(1)
            END IF
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .EQ. 0) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(j)
              j = j + 1
              CALL PUSHCONTROL1B(1)
            END IF
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    parameters_b%control%x = 0.0_4
    DO i=setup%nos,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO col=mesh%ncol,1,-1
          DO row=mesh%nrow,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              parameters_b%control%x(j) = parameters_b%control%x(j) + &
&               parameters_b%opr_initial_states%values(row, col, i)
              parameters_b%opr_initial_states%values(row, col, i) = &
&               0.0_4
              CALL POPINTEGER4(j)
            END IF
          END DO
        END DO
      END IF
    END DO
    DO i=setup%nop,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO col=mesh%ncol,1,-1
          DO row=mesh%nrow,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              parameters_b%control%x(j) = parameters_b%control%x(j) + &
&               parameters_b%opr_parameters%values(row, col, i)
              parameters_b%opr_parameters%values(row, col, i) = 0.0_4
              CALL POPINTEGER4(j)
            END IF
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE DISTRIBUTED_CONTROL_TO_PARAMETERS_B

  SUBROUTINE DISTRIBUTED_CONTROL_TO_PARAMETERS(setup, mesh, parameters, &
&   options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, row, col
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .NE. 0) THEN
              j = j + 1
              parameters%opr_parameters%values(row, col, i) = parameters&
&               %control%x(j)
            END IF
          END DO
        END DO
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        DO col=1,mesh%ncol
          DO row=1,mesh%nrow
            IF (mesh%active_cell(row, col) .NE. 0) THEN
              j = j + 1
              parameters%opr_initial_states%values(row, col, i) = &
&               parameters%control%x(j)
            END IF
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE DISTRIBUTED_CONTROL_TO_PARAMETERS

  SUBROUTINE MULTI_LINEAR_PARAMETERS_TO_CONTROL(setup, mesh, input_data&
&   , parameters, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: n, i, j, k
    REAL(sp) :: y, l, u
    LOGICAL, DIMENSION(mesh%nrow, mesh%ncol) :: ac_mask
    INTRINSIC SUM
    CALL MULTI_LINEAR_GET_CONTROL_SIZE(setup, options, n)
    CALL CONTROLDT_INITIALISE(parameters%control, n)
    ac_mask = mesh%active_cell(:, :) .EQ. 1
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        y = SUM(parameters%opr_parameters%values(:, :, i), mask=ac_mask)&
&         /mesh%nac
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL INV_SCALED_SIGMOID(y, l, u, parameters%control%x(j))
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .EQ. 1) &
&         THEN
            j = j + 1
            parameters%control%x(j) = 0._sp
          END IF
        END DO
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        y = SUM(parameters%opr_initial_states%values(:, :, i), mask=&
&         ac_mask)/mesh%nac
        l = options%optimize%l_opr_initial_states(i)
        u = options%optimize%u_opr_initial_states(i)
        CALL INV_SCALED_SIGMOID(y, l, u, parameters%control%x(j))
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .EQ. &
&             1) THEN
            j = j + 1
            parameters%control%x(j) = 0._sp
          END IF
        END DO
      END IF
    END DO
!~         parameters%control%x_bkg = parameters%control%x
    parameters%control%l_bkg = parameters%control%l
    parameters%control%u_bkg = parameters%control%u
    parameters%control%nbd = 0
  END SUBROUTINE MULTI_LINEAR_PARAMETERS_TO_CONTROL

!  Differentiation of multi_linear_control_to_parameters in forward (tangent) mode (with options fixinterface noISIZE OpenMP cont
!ext):
!   variations   of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE MULTI_LINEAR_CONTROL_TO_PARAMETERS_D(setup, mesh, &
&   input_data, parameters, parameters_d, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, k
    REAL(sp) :: l, u
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d, norm_desc
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d_d
    j = 0
    parameters_d%opr_parameters%values = 0.0_4
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        wa2d_d = parameters_d%control%x(j)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .EQ. 1) &
&         THEN
            j = j + 1
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            wa2d_d = wa2d_d + norm_desc*parameters_d%control%x(j)
            wa2d = wa2d + parameters%control%x(j)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D_D(wa2d, wa2d_d, l, u, parameters%&
&                          opr_parameters%values(:, :, i), parameters_d%&
&                          opr_parameters%values(:, :, i))
      END IF
    END DO
    parameters_d%opr_initial_states%values = 0.0_4
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        wa2d_d = parameters_d%control%x(j)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .EQ. &
&             1) THEN
            j = j + 1
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            wa2d_d = wa2d_d + norm_desc*parameters_d%control%x(j)
            wa2d = wa2d + parameters%control%x(j)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_initial_states(i)
        u = options%optimize%u_opr_initial_states(i)
        CALL SCALED_SIGMOIDE2D_D(wa2d, wa2d_d, l, u, parameters%&
&                          opr_initial_states%values(:, :, i), &
&                          parameters_d%opr_initial_states%values(:, :, &
&                          i))
      END IF
    END DO
  END SUBROUTINE MULTI_LINEAR_CONTROL_TO_PARAMETERS_D

!  Differentiation of multi_linear_control_to_parameters in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP cont
!ext):
!   gradient     of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE MULTI_LINEAR_CONTROL_TO_PARAMETERS_B(setup, mesh, &
&   input_data, parameters, parameters_b, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, k
    REAL(sp) :: l, u
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d, norm_desc
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d_b
    INTEGER :: branch
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        CALL PUSHREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .NE. 1) &
&         THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(j)
            j = j + 1
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            wa2d = wa2d + parameters%control%x(j)*norm_desc
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_parameters%&
&                        values(:, :, i))
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        CALL PUSHREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .NE. &
&             1) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(j)
            j = j + 1
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            wa2d = wa2d + parameters%control%x(j)*norm_desc
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        l = options%optimize%l_opr_initial_states(i)
        u = options%optimize%u_opr_initial_states(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_initial_states&
&                        %values(:, :, i))
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    parameters_b%control%x = 0.0_4
    DO i=setup%nos,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        l = options%optimize%l_opr_initial_states(i)
        u = options%optimize%u_opr_initial_states(i)
        CALL SCALED_SIGMOIDE2D_B(wa2d, wa2d_b, l, u, parameters%&
&                          opr_initial_states%values(:, :, i), &
&                          parameters_b%opr_initial_states%values(:, :, &
&                          i))
        parameters_b%opr_initial_states%values(:, :, i) = 0.0_4
        DO k=setup%nd,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&             norm_desc*wa2d_b)
            CALL POPINTEGER4(j)
          END IF
        END DO
        CALL POPREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&         wa2d_b)
        CALL POPINTEGER4(j)
      END IF
    END DO
    DO i=setup%nop,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D_B(wa2d, wa2d_b, l, u, parameters%&
&                          opr_parameters%values(:, :, i), parameters_b%&
&                          opr_parameters%values(:, :, i))
        parameters_b%opr_parameters%values(:, :, i) = 0.0_4
        DO k=setup%nd,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&             norm_desc*wa2d_b)
            CALL POPINTEGER4(j)
          END IF
        END DO
        CALL POPREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&         wa2d_b)
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE MULTI_LINEAR_CONTROL_TO_PARAMETERS_B

  SUBROUTINE MULTI_LINEAR_CONTROL_TO_PARAMETERS(setup, mesh, input_data&
&   , parameters, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, k
    REAL(sp) :: l, u
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d, norm_desc
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .EQ. 1) &
&         THEN
            j = j + 1
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            wa2d = wa2d + parameters%control%x(j)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_parameters%&
&                        values(:, :, i))
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .EQ. &
&             1) THEN
            j = j + 1
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            wa2d = wa2d + parameters%control%x(j)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_initial_states(i)
        u = options%optimize%u_opr_initial_states(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_initial_states&
&                        %values(:, :, i))
      END IF
    END DO
  END SUBROUTINE MULTI_LINEAR_CONTROL_TO_PARAMETERS

  SUBROUTINE MULTI_POLYNOMIAL_PARAMETERS_TO_CONTROL(setup, mesh, &
&   input_data, parameters, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: n, i, j, k
    REAL(sp) :: y, l, u
    LOGICAL, DIMENSION(mesh%nrow, mesh%ncol) :: ac_mask
    INTRINSIC SUM
    CALL MULTI_POLYNOMIAL_GET_CONTROL_SIZE(setup, options, n)
    CALL CONTROLDT_INITIALISE(parameters%control, n)
    ac_mask = mesh%active_cell(:, :) .EQ. 1
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        y = SUM(parameters%opr_parameters%values(:, :, i), mask=ac_mask)&
&         /mesh%nac
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL INV_SCALED_SIGMOID(y, l, u, parameters%control%x(j))
        parameters%control%nbd(j) = 0
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .EQ. 1) &
&         THEN
            j = j + 2
            parameters%control%x(j-1) = 0._sp
            parameters%control%nbd(j-1) = 0
            parameters%control%x(j) = 1._sp
            parameters%control%l(j) = 0.5_sp
            parameters%control%u(j) = 2._sp
            parameters%control%nbd(j) = 2
          END IF
        END DO
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        y = SUM(parameters%opr_initial_states%values(:, :, i), mask=&
&         ac_mask)/mesh%nac
        l = options%optimize%l_opr_initial_states(i)
        u = options%optimize%u_opr_initial_states(i)
        CALL INV_SCALED_SIGMOID(y, l, u, parameters%control%x(j))
        parameters%control%nbd(j) = 0
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .EQ. &
&             1) THEN
            j = j + 2
            parameters%control%x(j-1) = 0._sp
            parameters%control%nbd(j-1) = 0
            parameters%control%x(j) = 1._sp
            parameters%control%l(j) = 0.5_sp
            parameters%control%u(j) = 2._sp
            parameters%control%nbd(j) = 2
          END IF
        END DO
      END IF
    END DO
!~         parameters%control%x_bkg = parameters%control%x
    parameters%control%l_bkg = parameters%control%l
    parameters%control%u_bkg = parameters%control%u
  END SUBROUTINE MULTI_POLYNOMIAL_PARAMETERS_TO_CONTROL

!  Differentiation of multi_polynomial_control_to_parameters in forward (tangent) mode (with options fixinterface noISIZE OpenMP 
!context):
!   variations   of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS_D(setup, mesh, &
&   input_data, parameters, parameters_d, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, k
    REAL :: l, u
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d, norm_desc
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d_d, norm_desc_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: temp
    j = 0
    parameters_d%opr_parameters%values = 0.0_4
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        wa2d_d = parameters_d%control%x(j)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .EQ. 1) &
&         THEN
            j = j + 2
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            temp = norm_desc**parameters%control%x(j)
            WHERE (norm_desc .LE. 0.0) 
              norm_desc_d = 0.0_4
            ELSEWHERE
              norm_desc_d = temp*LOG(norm_desc)*parameters_d%control%x(j&
&               )
            END WHERE
            norm_desc = temp
            wa2d_d = wa2d_d + norm_desc*parameters_d%control%x(j-1) + &
&             parameters%control%x(j-1)*norm_desc_d
            wa2d = wa2d + parameters%control%x(j-1)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D_D(wa2d, wa2d_d, l, u, parameters%&
&                          opr_parameters%values(:, :, i), parameters_d%&
&                          opr_parameters%values(:, :, i))
      END IF
    END DO
    parameters_d%opr_initial_states%values = 0.0_4
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        wa2d_d = parameters_d%control%x(j)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .EQ. &
&             1) THEN
            j = j + 2
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            temp = norm_desc**parameters%control%x(j)
            WHERE (norm_desc .LE. 0.0) 
              norm_desc_d = 0.0_4
            ELSEWHERE
              norm_desc_d = temp*LOG(norm_desc)*parameters_d%control%x(j&
&               )
            END WHERE
            norm_desc = temp
            wa2d_d = wa2d_d + norm_desc*parameters_d%control%x(j-1) + &
&             parameters%control%x(j-1)*norm_desc_d
            wa2d = wa2d + parameters%control%x(j-1)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D_D(wa2d, wa2d_d, l, u, parameters%&
&                          opr_initial_states%values(:, :, i), &
&                          parameters_d%opr_initial_states%values(:, :, &
&                          i))
      END IF
    END DO
  END SUBROUTINE MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS_D

!  Differentiation of multi_polynomial_control_to_parameters in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP 
!context):
!   gradient     of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS_B(setup, mesh, &
&   input_data, parameters, parameters_b, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, k
    REAL :: l, u
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d, norm_desc
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d_b, norm_desc_b
    INTEGER :: branch
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        CALL PUSHREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .NE. 1) &
&         THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(j)
            j = j + 2
            CALL PUSHREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            CALL PUSHREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            norm_desc = norm_desc**parameters%control%x(j)
            wa2d = wa2d + parameters%control%x(j-1)*norm_desc
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_parameters%&
&                        values(:, :, i))
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .NE. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(j)
        j = j + 1
        CALL PUSHREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .NE. &
&             1) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(j)
            j = j + 2
            CALL PUSHREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            CALL PUSHREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            norm_desc = norm_desc**parameters%control%x(j)
            wa2d = wa2d + parameters%control%x(j-1)*norm_desc
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_initial_states&
&                        %values(:, :, i))
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    parameters_b%control%x = 0.0_4
    DO i=setup%nos,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D_B(wa2d, wa2d_b, l, u, parameters%&
&                          opr_initial_states%values(:, :, i), &
&                          parameters_b%opr_initial_states%values(:, :, &
&                          i))
        parameters_b%opr_initial_states%values(:, :, i) = 0.0_4
        DO k=setup%nd,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            norm_desc_b = 0.0_4
            parameters_b%control%x(j-1) = parameters_b%control%x(j-1) + &
&             SUM(norm_desc*wa2d_b)
            norm_desc_b = parameters%control%x(j-1)*wa2d_b
            CALL POPREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&             norm_desc**parameters%control%x(j)*LOG(norm_desc)*&
&             norm_desc_b, MASK=.NOT.norm_desc.LE.0.0)
            CALL POPREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            CALL POPINTEGER4(j)
          END IF
        END DO
        CALL POPREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&         wa2d_b)
        CALL POPINTEGER4(j)
      END IF
    END DO
    DO i=setup%nop,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D_B(wa2d, wa2d_b, l, u, parameters%&
&                          opr_parameters%values(:, :, i), parameters_b%&
&                          opr_parameters%values(:, :, i))
        parameters_b%opr_parameters%values(:, :, i) = 0.0_4
        DO k=setup%nd,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            norm_desc_b = 0.0_4
            parameters_b%control%x(j-1) = parameters_b%control%x(j-1) + &
&             SUM(norm_desc*wa2d_b)
            norm_desc_b = parameters%control%x(j-1)*wa2d_b
            CALL POPREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&             norm_desc**parameters%control%x(j)*LOG(norm_desc)*&
&             norm_desc_b, MASK=.NOT.norm_desc.LE.0.0)
            CALL POPREAL4ARRAY(norm_desc, mesh%nrow*mesh%ncol)
            CALL POPINTEGER4(j)
          END IF
        END DO
        CALL POPREAL4ARRAY(wa2d, mesh%nrow*mesh%ncol)
        parameters_b%control%x(j) = parameters_b%control%x(j) + SUM(&
&         wa2d_b)
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS_B

  SUBROUTINE MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS(setup, mesh, &
&   input_data, parameters, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTEGER :: i, j, k
    REAL :: l, u
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: wa2d, norm_desc
    j = 0
    DO i=1,setup%nop
      IF (options%optimize%opr_parameters(i) .EQ. 1) THEN
        j = j + 1
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_parameters_descriptor(k, i) .EQ. 1) &
&         THEN
            j = j + 2
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            norm_desc = norm_desc**parameters%control%x(j)
            wa2d = wa2d + parameters%control%x(j-1)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_parameters%&
&                        values(:, :, i))
      END IF
    END DO
    DO i=1,setup%nos
      IF (options%optimize%opr_initial_states(i) .EQ. 1) THEN
        j = j + 1
        wa2d = parameters%control%x(j)
        DO k=1,setup%nd
          IF (options%optimize%opr_initial_states_descriptor(k, i) .EQ. &
&             1) THEN
            j = j + 2
            norm_desc = (input_data%physio_data%descriptor(:, :, k)-&
&             input_data%physio_data%l_descriptor(k))/(input_data%&
&             physio_data%u_descriptor(k)-input_data%physio_data%&
&             l_descriptor(k))
            norm_desc = norm_desc**parameters%control%x(j)
            wa2d = wa2d + parameters%control%x(j-1)*norm_desc
          END IF
        END DO
        l = options%optimize%l_opr_parameters(i)
        u = options%optimize%u_opr_parameters(i)
        CALL SCALED_SIGMOIDE2D(wa2d, l, u, parameters%opr_initial_states&
&                        %values(:, :, i))
      END IF
    END DO
  END SUBROUTINE MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS

  SUBROUTINE CONTROL_TFM(parameters, options)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    SELECT CASE  (options%optimize%control_tfm) 
    CASE ('sbs') 
      CALL SBS_CONTROL_TFM(parameters)
    CASE ('normalize') 
      CALL NORMALIZE_CONTROL_TFM(parameters)
    END SELECT
  END SUBROUTINE CONTROL_TFM

!  Differentiation of inv_control_tfm in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(parameters.control.x)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.control.l:in
!                parameters.control.u:in parameters.control.l_bkg:in
!                parameters.control.u_bkg:in
  SUBROUTINE INV_CONTROL_TFM_D(parameters, parameters_d, options)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    SELECT CASE  (options%optimize%control_tfm) 
    CASE ('sbs') 
      CALL SBS_INV_CONTROL_TFM_D(parameters, parameters_d)
    CASE ('normalize') 
      CALL NORMALIZE_INV_CONTROL_TFM_D(parameters, parameters_d)
    END SELECT
  END SUBROUTINE INV_CONTROL_TFM_D

!  Differentiation of inv_control_tfm in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(parameters.control.x)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.control.l:in
!                parameters.control.u:in parameters.control.l_bkg:in
!                parameters.control.u_bkg:in
  SUBROUTINE INV_CONTROL_TFM_B(parameters, parameters_b, options)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    SELECT CASE  (options%optimize%control_tfm) 
    CASE ('sbs') 
      CALL PUSHREAL4ARRAY(parameters%control%x, SIZE(parameters%control%&
&                   x, 1))
      CALL SBS_INV_CONTROL_TFM(parameters)
      CALL POPREAL4ARRAY(parameters%control%x, SIZE(parameters%control%x&
&                  , 1))
      CALL SBS_INV_CONTROL_TFM_B(parameters, parameters_b)
    CASE ('normalize') 
      CALL NORMALIZE_INV_CONTROL_TFM(parameters)
      CALL NORMALIZE_INV_CONTROL_TFM_B(parameters, parameters_b)
    END SELECT
  END SUBROUTINE INV_CONTROL_TFM_B

  SUBROUTINE INV_CONTROL_TFM(parameters, options)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    SELECT CASE  (options%optimize%control_tfm) 
    CASE ('sbs') 
      CALL SBS_INV_CONTROL_TFM(parameters)
    CASE ('normalize') 
      CALL NORMALIZE_INV_CONTROL_TFM(parameters)
    END SELECT
  END SUBROUTINE INV_CONTROL_TFM

  SUBROUTINE PARAMETERS_TO_CONTROL(setup, mesh, input_data, parameters, &
&   options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    SELECT CASE  (options%optimize%mapping) 
    CASE ('uniform') 
      CALL UNIFORM_PARAMETERS_TO_CONTROL(setup, mesh, parameters, &
&                                  options)
    CASE ('distributed') 
      CALL DISTRIBUTED_PARAMETERS_TO_CONTROL(setup, mesh, parameters, &
&                                      options)
    CASE ('multi-linear') 
      CALL MULTI_LINEAR_PARAMETERS_TO_CONTROL(setup, mesh, input_data, &
&                                       parameters, options)
    CASE ('multi-polynomial') 
      CALL MULTI_POLYNOMIAL_PARAMETERS_TO_CONTROL(setup, mesh, &
&                                           input_data, parameters, &
&                                           options)
    END SELECT
    CALL CONTROL_TFM(parameters, options)
  END SUBROUTINE PARAMETERS_TO_CONTROL

!  Differentiation of control_to_parameters in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.control.l:in
!                parameters.control.u:in parameters.control.l_bkg:in
!                parameters.control.u_bkg:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE CONTROL_TO_PARAMETERS_D(setup, mesh, input_data, parameters&
&   , parameters_d, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTRINSIC ALLOCATED
    IF (.NOT.ALLOCATED(parameters%control%x)) THEN
      parameters_d%opr_parameters%values = 0.0_4
      parameters_d%opr_initial_states%values = 0.0_4
    ELSE
      CALL INV_CONTROL_TFM_D(parameters, parameters_d, options)
      SELECT CASE  (options%optimize%mapping) 
      CASE ('uniform') 
        CALL UNIFORM_CONTROL_TO_PARAMETERS_D(setup, mesh, parameters, &
&                                      parameters_d, options)
      CASE ('distributed') 
        CALL DISTRIBUTED_CONTROL_TO_PARAMETERS_D(setup, mesh, parameters&
&                                          , parameters_d, options)
      CASE ('multi-linear') 
        CALL MULTI_LINEAR_CONTROL_TO_PARAMETERS_D(setup, mesh, &
&                                           input_data, parameters, &
&                                           parameters_d, options)
      CASE ('multi-polynomial') 
        CALL MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS_D(setup, mesh, &
&                                               input_data, parameters, &
&                                               parameters_d, options)
      CASE DEFAULT
        parameters_d%opr_parameters%values = 0.0_4
        parameters_d%opr_initial_states%values = 0.0_4
      END SELECT
    END IF
  END SUBROUTINE CONTROL_TO_PARAMETERS_D

!  Differentiation of control_to_parameters in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   with respect to varying inputs: *(parameters.control.x)
!   Plus diff mem management of: parameters.control.x:in parameters.control.l:in
!                parameters.control.u:in parameters.control.l_bkg:in
!                parameters.control.u_bkg:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in
  SUBROUTINE CONTROL_TO_PARAMETERS_B(setup, mesh, input_data, parameters&
&   , parameters_b, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTRINSIC ALLOCATED
    IF (.NOT.ALLOCATED(parameters%control%x)) THEN
      parameters_b%control%x = 0.0_4
    ELSE
      CALL PUSHREAL4ARRAY(parameters%control%x, SIZE(parameters%control%&
&                   x, 1))
      CALL INV_CONTROL_TFM(parameters, options)
      SELECT CASE  (options%optimize%mapping) 
      CASE ('uniform') 
        CALL UNIFORM_CONTROL_TO_PARAMETERS(setup, mesh, parameters, &
&                                    options)
        CALL UNIFORM_CONTROL_TO_PARAMETERS_B(setup, mesh, parameters, &
&                                      parameters_b, options)
      CASE ('distributed') 
        CALL DISTRIBUTED_CONTROL_TO_PARAMETERS(setup, mesh, parameters, &
&                                        options)
        CALL DISTRIBUTED_CONTROL_TO_PARAMETERS_B(setup, mesh, parameters&
&                                          , parameters_b, options)
      CASE ('multi-linear') 
        CALL MULTI_LINEAR_CONTROL_TO_PARAMETERS(setup, mesh, input_data&
&                                         , parameters, options)
        CALL MULTI_LINEAR_CONTROL_TO_PARAMETERS_B(setup, mesh, &
&                                           input_data, parameters, &
&                                           parameters_b, options)
      CASE ('multi-polynomial') 
        CALL MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS(setup, mesh, &
&                                             input_data, parameters, &
&                                             options)
        CALL MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS_B(setup, mesh, &
&                                               input_data, parameters, &
&                                               parameters_b, options)
      CASE DEFAULT
        parameters_b%control%x = 0.0_4
      END SELECT
      CALL POPREAL4ARRAY(parameters%control%x, SIZE(parameters%control%x&
&                  , 1))
      CALL INV_CONTROL_TFM_B(parameters, parameters_b, options)
    END IF
  END SUBROUTINE CONTROL_TO_PARAMETERS_B

  SUBROUTINE CONTROL_TO_PARAMETERS(setup, mesh, input_data, parameters, &
&   options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    INTRINSIC ALLOCATED
    IF (.NOT.ALLOCATED(parameters%control%x)) THEN
      RETURN
    ELSE
      CALL INV_CONTROL_TFM(parameters, options)
      SELECT CASE  (options%optimize%mapping) 
      CASE ('uniform') 
        CALL UNIFORM_CONTROL_TO_PARAMETERS(setup, mesh, parameters, &
&                                    options)
      CASE ('distributed') 
        CALL DISTRIBUTED_CONTROL_TO_PARAMETERS(setup, mesh, parameters, &
&                                        options)
      CASE ('multi-linear') 
        CALL MULTI_LINEAR_CONTROL_TO_PARAMETERS(setup, mesh, input_data&
&                                         , parameters, options)
      CASE ('multi-polynomial') 
        CALL MULTI_POLYNOMIAL_CONTROL_TO_PARAMETERS(setup, mesh, &
&                                             input_data, parameters, &
&                                             options)
      END SELECT
    END IF
  END SUBROUTINE CONTROL_TO_PARAMETERS

END MODULE MWD_PARAMETERS_MANIPULATION_DIFF

!%      (MD) Module Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - gr_interception
!%      - gr_production
!%      - gr_exchange
!%      - gr_transfer
MODULE MD_GR_OPERATOR_DIFF
!% only : sp
  USE MD_CONSTANT
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: hi ei pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_D(prcp, pet, ci, ci_d, hi, hi_d, pn, pn_d, &
&   ei, ei_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(IN) :: ci_d
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_d
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp), INTENT(OUT) :: pn_d, ei_d
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp
    IF (pet .GT. prcp + hi*ci) THEN
      ei_d = ci*hi_d + hi*ci_d
      ei = prcp + hi*ci
    ELSE
      ei = pet
      ei_d = 0.0_4
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn_d = ci*hi_d - (1._sp-hi)*ci_d - ei_d
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
      pn_d = 0.0_4
    END IF
    temp = (prcp-ei-pn)/ci
    hi_d = hi_d + (-ei_d-pn_d-temp*ci_d)/ci
    hi = hi + temp
  END SUBROUTINE GR_INTERCEPTION_D

!  Differentiation of gr_interception in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: hi ei ci pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_B(prcp, pet, ci, ci_b, hi, hi_b, pn, pn_b, &
&   ei, ei_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp) :: ci_b
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_b
    REAL(sp) :: pn, ei
    REAL(sp) :: pn_b, ei_b
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp_b
    INTEGER :: branch
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      CALL PUSHREAL4(pn)
      pn = prcp - ci*(1._sp-hi) - ei
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL4(pn)
      pn = 0._sp
      CALL PUSHCONTROL1B(1)
    END IF
    temp_b = hi_b/ci
    ei_b = ei_b - temp_b
    pn_b = pn_b - temp_b
    ci_b = ci_b - (prcp-ei-pn)*temp_b/ci
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(pn)
      ci_b = ci_b - (1._sp-hi)*pn_b
      hi_b = hi_b + ci*pn_b
      ei_b = ei_b - pn_b
    ELSE
      CALL POPREAL4(pn)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      hi_b = hi_b + ci*ei_b
      ci_b = ci_b + hi*ei_b
    END IF
  END SUBROUTINE GR_INTERCEPTION_B

!% TODO comment
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: hp perc pr
!   with respect to varying inputs: hp en cp pn
  SUBROUTINE GR_PRODUCTION_D(pn, pn_d, en, en_d, cp, cp_d, beta, hp, &
&   hp_d, pr, pr_d, perc, perc_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(IN) :: pn_d, en_d, cp_d
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_d
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp), INTENT(OUT) :: pr_d, perc_d
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_d, ps_d, es_d, hp_imd_d
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    inv_cp_d = -(cp_d/cp**2)
    inv_cp = 1._sp/cp
    pr = 0._sp
    temp = TANH(pn*inv_cp)
    temp0 = TANH(pn*inv_cp)
    temp1 = cp*(-(hp*hp)+1._sp)
    temp2 = temp1*temp0/(hp*temp+1._sp)
    ps_d = (temp0*((1._sp-hp**2)*cp_d-cp*2*hp*hp_d)+temp1*(1.0-TANH(pn*&
&     inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)-temp2*(temp*hp_d+hp*(1.0-&
&     TANH(pn*inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)))/(hp*temp+1._sp)
    ps = temp2
    temp2 = TANH(en*inv_cp)
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp = temp0*temp1/((-hp+1._sp)*temp2+1._sp)
    es_d = (temp1*((2._sp-hp)*(cp*hp_d+hp*cp_d)-hp*cp*hp_d)+temp0*(1.0-&
&     TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp*((1._sp-hp)*(&
&     1.0-TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp2*hp_d))/((&
&     1._sp-hp)*temp2+1._sp)
    es = temp
    hp_imd_d = hp_d + inv_cp*(ps_d-es_d) + (ps-es)*inv_cp_d
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      pr_d = pn_d - cp*(hp_imd_d-hp_d) - (hp_imd-hp)*cp_d
      pr = pn - (hp_imd-hp)*cp
    ELSE
      pr_d = 0.0_4
    END IF
    pwx1_d = 4*hp_imd**3*hp_imd_d/beta**4
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1_d = -(0.25_sp*pwx1**(-1.25)*pwx1_d)
    pwr1 = pwx1**(-0.25_sp)
    perc_d = (1._sp-pwr1)*(cp*hp_imd_d+hp_imd*cp_d) - hp_imd*cp*pwr1_d
    perc = hp_imd*cp*(1._sp-pwr1)
    hp_d = hp_imd_d - inv_cp*perc_d - perc*inv_cp_d
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION_D

!  Differentiation of gr_production in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: hp cp perc pr
!   with respect to varying inputs: hp en cp pn
  SUBROUTINE GR_PRODUCTION_B(pn, pn_b, en, en_b, cp, cp_b, beta, hp, &
&   hp_b, pr, pr_b, perc, perc_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp) :: pn_b, en_b, cp_b
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_b
    REAL(sp) :: pr, perc
    REAL(sp) :: pr_b, perc_b
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_b, ps_b, es_b, hp_imd_b
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp_b
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    REAL(sp) :: temp3
    REAL(sp) :: temp_b0
    REAL(sp) :: temp_b1
    REAL(sp) :: temp4
    REAL(sp) :: temp_b2
    REAL(sp) :: temp_b3
    REAL(sp) :: temp_b4
    REAL(sp) :: temp_b5
    INTEGER :: branch
    inv_cp = 1._sp/cp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    inv_cp = 1._sp/cp
    perc_b = perc_b - inv_cp*hp_b
    inv_cp_b = -(perc*hp_b)
    cp_b = cp_b + hp_imd*(1._sp-pwr1)*perc_b
    pwr1_b = -(hp_imd*cp*perc_b)
    pwx1_b = -(0.25_sp*pwx1**(-1.25)*pwr1_b)
    hp_imd_b = hp_b + cp*(1._sp-pwr1)*perc_b + 4*hp_imd**3*pwx1_b/beta**&
&     4
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pn_b = pr_b
      hp_imd_b = hp_imd_b - cp*pr_b
      hp_b = cp*pr_b
      cp_b = cp_b - (hp_imd-hp)*pr_b
    ELSE
      hp_b = 0.0_4
      pn_b = 0.0_4
    END IF
    es_b = -(inv_cp*hp_imd_b)
    temp4 = TANH(en*inv_cp)
    temp3 = (-hp+1._sp)*temp4 + 1._sp
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp_b3 = es_b/temp3
    temp_b = (2._sp-hp)*temp1*temp_b3
    temp_b0 = -(temp0*temp1*temp_b3/temp3)
    hp_b = hp_b + hp_imd_b + cp*temp_b - hp*cp*temp1*temp_b3 - temp4*&
&     temp_b0
    ps_b = inv_cp*hp_imd_b
    temp_b4 = (1.0-TANH(en*inv_cp)**2)*temp0*temp_b3
    temp_b5 = (1.0-TANH(en*inv_cp)**2)*(1._sp-hp)*temp_b0
    en_b = inv_cp*temp_b5 + inv_cp*temp_b4
    cp_b = cp_b + hp*temp_b
    temp = TANH(pn*inv_cp)
    temp0 = hp*temp + 1._sp
    temp1 = TANH(pn*inv_cp)
    temp2 = cp*(-(hp*hp)+1._sp)
    temp_b = ps_b/temp0
    temp_b0 = (1.0-TANH(pn*inv_cp)**2)*temp2*temp_b
    temp_b1 = -(temp2*temp1*temp_b/temp0)
    hp_b = hp_b + temp*temp_b1 - 2*hp*cp*temp1*temp_b
    temp_b2 = (1.0-TANH(pn*inv_cp)**2)*hp*temp_b1
    inv_cp_b = inv_cp_b + (ps-es)*hp_imd_b + en*temp_b5 + en*temp_b4 + &
&     pn*temp_b2 + pn*temp_b0
    cp_b = cp_b + (1._sp-hp**2)*temp1*temp_b - inv_cp_b/cp**2
    pn_b = pn_b + inv_cp*temp_b2 + inv_cp*temp_b0
  END SUBROUTINE GR_PRODUCTION_B

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: l
!   with respect to varying inputs: kexc ht
  SUBROUTINE GR_EXCHANGE_D(kexc, kexc_d, ht, ht_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: kexc
    REAL(sp), INTENT(IN) :: kexc_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    REAL(sp) :: temp
    temp = ht**3.5_sp
    l_d = temp*kexc_d + kexc*3.5_sp*ht**2.5*ht_d
    l = kexc*temp
  END SUBROUTINE GR_EXCHANGE_D

!  Differentiation of gr_exchange in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: l kexc ht
!   with respect to varying inputs: kexc ht
  SUBROUTINE GR_EXCHANGE_B(kexc, kexc_b, ht, ht_b, l, l_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: kexc
    REAL(sp) :: kexc_b
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_b
    REAL(sp) :: l
    REAL(sp) :: l_b
    kexc_b = kexc_b + ht**3.5_sp*l_b
    ht_b = ht_b + 3.5_sp*ht**2.5*kexc*l_b
  END SUBROUTINE GR_EXCHANGE_B

  SUBROUTINE GR_EXCHANGE(kexc, ht, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: kexc
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: l
    l = kexc*ht**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_threshold_exchange in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: l
!   with respect to varying inputs: aexc kexc ht
  SUBROUTINE GR_THRESHOLD_EXCHANGE_D(kexc, kexc_d, ht, ht_d, aexc, &
&   aexc_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: kexc, aexc
    REAL(sp), INTENT(IN) :: kexc_d, aexc_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    l_d = (ht-aexc)*kexc_d + kexc*(ht_d-aexc_d)
    l = kexc*(ht-aexc)
  END SUBROUTINE GR_THRESHOLD_EXCHANGE_D

!  Differentiation of gr_threshold_exchange in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: aexc l kexc ht
!   with respect to varying inputs: aexc kexc ht
  SUBROUTINE GR_THRESHOLD_EXCHANGE_B(kexc, kexc_b, ht, ht_b, aexc, &
&   aexc_b, l, l_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: kexc, aexc
    REAL(sp) :: kexc_b, aexc_b
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_b
    REAL(sp) :: l
    REAL(sp) :: l_b
    kexc_b = kexc_b + (ht-aexc)*l_b
    ht_b = ht_b + kexc*l_b
    aexc_b = aexc_b - kexc*l_b
  END SUBROUTINE GR_THRESHOLD_EXCHANGE_B

  SUBROUTINE GR_THRESHOLD_EXCHANGE(kexc, ht, aexc, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: kexc, aexc
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: l
    l = kexc*(ht-aexc)
  END SUBROUTINE GR_THRESHOLD_EXCHANGE

!  Differentiation of gr_transfer in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: q ht
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFER_D(n, prcp, pr, pr_d, ct, ct_d, ht, ht_d, q, q_d&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(IN) :: pr_d, ct_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(OUT) :: q_d
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_d, ht_imd_d
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1_d = ct*ht_d + ht*ct_d
      pwx1 = ht*ct
      pwy1 = -nm1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      END IF
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        pwr2_d = 0.0_4
      ELSE
        pwr2_d = pwy2*ct**(pwy2-1)*ct_d
      END IF
      pwr2 = ct**pwy2
      pwx3_d = pwr1_d - pwr2_d
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwr3_d = 0.0_4
      ELSE
        pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
      END IF
      pwr3 = pwx3**pwy3
      pr_imd_d = pwr3_d - ct*ht_d - ht*ct_d
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd_d = pr_d
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd_d = ht_d + (pr_imd_d-pr_imd*ct_d/ct)/ct
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
      ht_imd_d = 0.0_4
    END IF
    pwx1_d = ct*ht_imd_d + ht_imd*ct_d
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*ct**(pwy2-1)*ct_d
    END IF
    pwr2 = ct**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    ht_d = (pwr3_d-pwr3*ct_d/ct)/ct
    ht = pwr3/ct
    q_d = ct*(ht_imd_d-ht_d) + (ht_imd-ht)*ct_d
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFER_D

!  Differentiation of gr_transfer in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: q ht ct
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFER_B(n, prcp, pr, pr_b, ct, ct_b, ht, ht_b, q, q_b&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp) :: pr_b, ct_b
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_b
    REAL(sp) :: q
    REAL(sp) :: q_b
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_b, ht_imd_b
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_b
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_b
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_b
    INTEGER :: branch
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
      CALL PUSHCONTROL1B(1)
    ELSE
      pr_imd = pr
      CALL PUSHCONTROL1B(0)
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
      CALL PUSHCONTROL1B(0)
    ELSE
      ht_imd = 1.e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(pwx1)
    pwx1 = ht_imd*ct
    CALL PUSHREAL4(pwy1)
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    CALL PUSHREAL4(pwy2)
    pwy2 = -nm1
    pwr2 = ct**pwy2
    CALL PUSHREAL4(pwx3)
    pwx3 = pwr1 + pwr2
    CALL PUSHREAL4(pwy3)
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    CALL PUSHREAL4(ht)
    ht = pwr3/ct
    pwx1 = ht_imd*ct
    nm1 = n - 1._sp
    pwy1 = -nm1
    pwy2 = -nm1
    d1pnm1 = 1._sp/nm1
    pwy3 = -d1pnm1
    ht_b = ht_b - ct*q_b
    pwr3_b = ht_b/ct
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwx3_b = 0.0_4
    ELSE
      pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
    END IF
    pwr1_b = pwx3_b
    pwr2_b = pwx3_b
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwx1_b = 0.0_4
    ELSE
      pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
    END IF
    ht_imd_b = ct*q_b + ct*pwx1_b
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      ct_b = ct_b + (ht_imd-ht)*q_b + ht_imd*pwx1_b - pwr3*ht_b/ct**2
    ELSE
      ct_b = ct_b + (ht_imd-ht)*q_b + pwy2*ct**(pwy2-1)*pwr2_b - pwr3*&
&       ht_b/ct**2 + ht_imd*pwx1_b
    END IF
    CALL POPREAL4(ht)
    CALL POPREAL4(pwy3)
    CALL POPREAL4(pwx3)
    CALL POPREAL4(pwy2)
    CALL POPREAL4(pwy1)
    CALL POPREAL4(pwx1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ht_b = ht_imd_b
      pr_imd_b = ht_imd_b/ct
      ct_b = ct_b - pr_imd*ht_imd_b/ct**2
    ELSE
      ht_b = 0.0_4
      pr_imd_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pr_b = pr_imd_b
    ELSE
      pwr3_b = pr_imd_b
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwx3_b = 0.0_4
      ELSE
        pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
      END IF
      pwr1_b = pwx3_b
      pwr2_b = -pwx3_b
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwx1_b = 0.0_4
      ELSE
        pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
      END IF
      ht_b = ht_b + ct*pwx1_b - ct*pr_imd_b
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        ct_b = ct_b + ht*pwx1_b - ht*pr_imd_b
      ELSE
        ct_b = ct_b + pwy2*ct**(pwy2-1)*pwr2_b - ht*pr_imd_b + ht*pwx1_b
      END IF
      pr_b = 0.0_4
    END IF
  END SUBROUTINE GR_TRANSFER_B

  SUBROUTINE GR_TRANSFER(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = ct**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    ht = pwr3/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFER

END MODULE MD_GR_OPERATOR_DIFF

!%      (MD) Module Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - upstream_discharge
!%      - linear_routing
!%      - kinematic_wave1d
MODULE MD_ROUTING_OPERATOR_DIFF
!% only : sp
  USE MD_CONSTANT
  IMPLICIT NONE

CONTAINS
!  Differentiation of upstream_discharge in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_D(nrow, ncol, row, col, dx, dy, fa, &
&   flwdir, q, q_d, qup, qup_d)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nrow, ncol
    INTEGER, INTENT(IN) :: row, col
    REAL(sp), INTENT(IN) :: dx, dy, fa
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    qup = 0._sp
    qup_d = 0.0_4
    DO i=1,8
      row_imd = row + drow(i)
      col_imd = col + dcol(i)
      IF (.NOT.(((row_imd .LT. 1 .OR. row_imd .GT. nrow) .OR. col_imd &
&         .LT. 1) .OR. col_imd .GT. ncol)) THEN
        IF (flwdir(row_imd, col_imd) .EQ. i) THEN
          qup_d = qup_d + q_d(row_imd, col_imd)
          qup = qup + q(row_imd, col_imd)
        END IF
      END IF
    END DO
  END SUBROUTINE UPSTREAM_DISCHARGE_D

!  Differentiation of upstream_discharge in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_B(nrow, ncol, row, col, dx, dy, fa, &
&   flwdir, q, q_b, qup, qup_b)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nrow, ncol
    INTEGER, INTENT(IN) :: row, col
    REAL(sp), INTENT(IN) :: dx, dy, fa
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol) :: q_b
    REAL(sp) :: qup
    REAL(sp) :: qup_b
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER :: branch
    DO i=1,8
      CALL PUSHINTEGER4(row_imd)
      row_imd = row + drow(i)
      CALL PUSHINTEGER4(col_imd)
      col_imd = col + dcol(i)
      IF (((row_imd .LT. 1 .OR. row_imd .GT. nrow) .OR. col_imd .LT. 1) &
&         .OR. col_imd .GT. ncol) THEN
        CALL PUSHCONTROL2B(0)
      ELSE IF (flwdir(row_imd, col_imd) .EQ. i) THEN
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    END DO
    DO i=8,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) q_b(row_imd, col_imd) = q_b(row_imd, col_imd)&
&           + qup_b
      END IF
      CALL POPINTEGER4(col_imd)
      CALL POPINTEGER4(row_imd)
    END DO
  END SUBROUTINE UPSTREAM_DISCHARGE_B

  SUBROUTINE UPSTREAM_DISCHARGE(nrow, ncol, row, col, dx, dy, fa, flwdir&
&   , q, qup)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nrow, ncol
    INTEGER, INTENT(IN) :: row, col
    REAL(sp), INTENT(IN) :: dx, dy, fa
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    qup = 0._sp
    DO i=1,8
      row_imd = row + drow(i)
      col_imd = col + dcol(i)
      IF (.NOT.(((row_imd .LT. 1 .OR. row_imd .GT. nrow) .OR. col_imd &
&         .LT. 1) .OR. col_imd .GT. ncol)) THEN
        IF (flwdir(row_imd, col_imd) .EQ. i) qup = qup + q(row_imd, &
&           col_imd)
      END IF
    END DO
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of linear_routing in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: hlr qrout
!   with respect to varying inputs: hlr qup llr
  SUBROUTINE LINEAR_ROUTING_D(dt, dx, dy, fa, llr, llr_d, hlr, hlr_d, &
&   qup, qup_d, qrout, qrout_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx, dy, fa
    REAL(sp), INTENT(IN) :: llr
    REAL(sp), INTENT(IN) :: llr_d
    REAL(sp), INTENT(INOUT) :: hlr, qup
    REAL(sp), INTENT(INOUT) :: hlr_d, qup_d
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp), INTENT(OUT) :: qrout_d
    REAL(sp) :: hlr_imd
    REAL(sp) :: hlr_imd_d
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    temp = 1e-3_sp*(fa-dx*dy)
    qup_d = dt*qup_d/temp
    qup = dt*(qup/temp)
    hlr_imd_d = hlr_d + qup_d
    hlr_imd = hlr + qup
    temp = dt/(60._sp*llr)
    arg1_d = temp*llr_d/llr
    arg1 = -temp
    temp = EXP(arg1)
    hlr_d = temp*hlr_imd_d + hlr_imd*EXP(arg1)*arg1_d
    hlr = hlr_imd*temp
    qrout_d = hlr_imd_d - hlr_d
    qrout = hlr_imd - hlr
    temp = 1e-3_sp*(fa-dx*dy)
    qrout_d = temp*qrout_d/dt
    qrout = temp*(qrout/dt)
  END SUBROUTINE LINEAR_ROUTING_D

!  Differentiation of linear_routing in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: hlr llr qrout
!   with respect to varying inputs: hlr qup llr
  SUBROUTINE LINEAR_ROUTING_B(dt, dx, dy, fa, llr, llr_b, hlr, hlr_b, &
&   qup, qup_b, qrout, qrout_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx, dy, fa
    REAL(sp), INTENT(IN) :: llr
    REAL(sp) :: llr_b
    REAL(sp), INTENT(INOUT) :: hlr, qup
    REAL(sp), INTENT(INOUT) :: hlr_b, qup_b
    REAL(sp) :: qrout
    REAL(sp) :: qrout_b
    REAL(sp) :: hlr_imd
    REAL(sp) :: hlr_imd_b
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    qup = qup*dt/(1e-3_sp*(fa-dx*dy))
    hlr_imd = hlr + qup
    arg1 = -(dt/(llr*60._sp))
    arg1 = -(dt/(llr*60._sp))
    qrout_b = (fa-dx*dy)*1e-3_sp*qrout_b/dt
    hlr_b = hlr_b - qrout_b
    hlr_imd_b = qrout_b + EXP(arg1)*hlr_b
    arg1_b = EXP(arg1)*hlr_imd*hlr_b
    llr_b = llr_b + dt*arg1_b/(llr**2*60._sp)
    hlr_b = hlr_imd_b
    qup_b = hlr_imd_b
    qup_b = dt*qup_b/(1e-3_sp*(fa-dx*dy))
  END SUBROUTINE LINEAR_ROUTING_B

  SUBROUTINE LINEAR_ROUTING(dt, dx, dy, fa, llr, hlr, qup, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx, dy, fa
    REAL(sp), INTENT(IN) :: llr
    REAL(sp), INTENT(INOUT) :: hlr, qup
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hlr_imd
    INTRINSIC EXP
    REAL(sp) :: arg1
    qup = qup*dt/(1e-3_sp*(fa-dx*dy))
    hlr_imd = hlr + qup
    arg1 = -(dt/(llr*60._sp))
    hlr = hlr_imd*EXP(arg1)
    qrout = hlr_imd - hlr
    qrout = qrout*1e-3_sp*(fa-dx*dy)/dt
  END SUBROUTINE LINEAR_ROUTING

!  Differentiation of kinematic_wave1d in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: qij
!   with respect to varying inputs: qim1j bkw qijm1 qlij akw qlijm1
  SUBROUTINE KINEMATIC_WAVE1D_D(dt, dx, akw, akw_d, bkw, bkw_d, qlijm1, &
&   qlijm1_d, qlij, qlij_d, qim1j, qim1j_d, qijm1, qijm1_d, qij, qij_d)
    IMPLICIT NONE
!% Non-Linear solution solved with Newton-Raphson
!% Commented while testing Linearized solution
!~         rhs = n1 + akw*wqijm1**bkw + n3
!~         iter = 0
!~         maxiter = 2
!~         rsd = 1._sp
!~         do while (abs(rsd) > 1e-6 .and. iter < maxiter)
!~             rsd = dtddx*qij + akw*qij**bkw - rhs
!~             rsd_d = dtddx + akw*bkw*qij**(bkw - 1._sp)
!~             qij = qij - rsd/rsd_d
!~             qij = max(qij, 0._sp)
!~             iter = iter + 1
!~         end do
    REAL(sp), INTENT(IN) :: dt, dx
    REAL(sp), INTENT(IN) :: akw, bkw
    REAL(sp), INTENT(IN) :: akw_d, bkw_d
    REAL(sp), INTENT(IN) :: qlijm1, qlij, qim1j, qijm1
    REAL(sp), INTENT(IN) :: qlijm1_d, qlij_d, qim1j_d, qijm1_d
    REAL(sp), INTENT(INOUT) :: qij
    REAL(sp), INTENT(INOUT) :: qij_d
    REAL(sp) :: wqlijm1, wqlij, wqim1j, wqijm1
    REAL(sp) :: wqlijm1_d, wqlij_d, wqim1j_d, wqijm1_d
    REAL(sp) :: dtddx, n1, n2, n3, d1, d2, rhs, rsd, rsd_d
    REAL(sp) :: n1_d, n2_d, n3_d, d2_d
    INTEGER :: iter, maxiter
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwy1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    IF (1e-6_sp .LT. qlijm1) THEN
      wqlijm1_d = qlijm1_d
      wqlijm1 = qlijm1
    ELSE
      wqlijm1 = 1e-6_sp
      wqlijm1_d = 0.0_4
    END IF
    IF (1e-6_sp .LT. qlij) THEN
      wqlij_d = qlij_d
      wqlij = qlij
    ELSE
      wqlij = 1e-6_sp
      wqlij_d = 0.0_4
    END IF
    IF (1e-6_sp .LT. qim1j) THEN
      wqim1j_d = qim1j_d
      wqim1j = qim1j
    ELSE
      wqim1j = 1e-6_sp
      wqim1j_d = 0.0_4
    END IF
    IF (1e-6_sp .LT. qijm1) THEN
      wqijm1_d = qijm1_d
      wqijm1 = qijm1
    ELSE
      wqijm1 = 1e-6_sp
      wqijm1_d = 0.0_4
    END IF
    dtddx = dt/dx
    d1 = dtddx
    pwx1_d = (wqijm1_d+wqim1j_d)/2._sp
    pwx1 = (wqijm1+wqim1j)/2._sp
    pwy1_d = bkw_d
    pwy1 = bkw - 1._sp
    temp = pwx1**pwy1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE IF (pwx1 .LE. 0.0) THEN
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d + temp*LOG(pwx1)*pwy1_d
    END IF
    pwr1 = temp
    d2_d = pwr1*(bkw*akw_d+akw*bkw_d) + akw*bkw*pwr1_d
    d2 = akw*bkw*pwr1
    n1_d = dtddx*wqim1j_d
    n1 = dtddx*wqim1j
    n2_d = d2*wqijm1_d + wqijm1*d2_d
    n2 = wqijm1*d2
    n3_d = dtddx*(wqlijm1_d+wqlij_d)/2._sp
    n3 = dtddx*(wqlijm1+wqlij)/2._sp
!% Linearized solution
    temp = (n1+n2+n3)/(d1+d2)
    qij_d = (n1_d+n2_d+n3_d-temp*d2_d)/(d1+d2)
    qij = temp
  END SUBROUTINE KINEMATIC_WAVE1D_D

!  Differentiation of kinematic_wave1d in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: bkw akw qij
!   with respect to varying inputs: qim1j bkw qijm1 qlij akw qlijm1
  SUBROUTINE KINEMATIC_WAVE1D_B(dt, dx, akw, akw_b, bkw, bkw_b, qlijm1, &
&   qlijm1_b, qlij, qlij_b, qim1j, qim1j_b, qijm1, qijm1_b, qij, qij_b)
    IMPLICIT NONE
!% Non-Linear solution solved with Newton-Raphson
!% Commented while testing Linearized solution
!~         rhs = n1 + akw*wqijm1**bkw + n3
!~         iter = 0
!~         maxiter = 2
!~         rsd = 1._sp
!~         do while (abs(rsd) > 1e-6 .and. iter < maxiter)
!~             rsd = dtddx*qij + akw*qij**bkw - rhs
!~             rsd_d = dtddx + akw*bkw*qij**(bkw - 1._sp)
!~             qij = qij - rsd/rsd_d
!~             qij = max(qij, 0._sp)
!~             iter = iter + 1
!~         end do
    REAL(sp), INTENT(IN) :: dt, dx
    REAL(sp), INTENT(IN) :: akw, bkw
    REAL(sp) :: akw_b, bkw_b
    REAL(sp), INTENT(IN) :: qlijm1, qlij, qim1j, qijm1
    REAL(sp) :: qlijm1_b, qlij_b, qim1j_b, qijm1_b
    REAL(sp), INTENT(INOUT) :: qij
    REAL(sp), INTENT(INOUT) :: qij_b
    REAL(sp) :: wqlijm1, wqlij, wqim1j, wqijm1
    REAL(sp) :: wqlijm1_b, wqlij_b, wqim1j_b, wqijm1_b
    REAL(sp) :: dtddx, n1, n2, n3, d1, d2, rhs, rsd, rsd_d
    REAL(sp) :: n1_b, n2_b, n3_b, d2_b
    INTEGER :: iter, maxiter
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwy1
    REAL(sp) :: pwy1_b
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: temp_b
    INTEGER :: branch
    IF (1e-6_sp .LT. qlijm1) THEN
      wqlijm1 = qlijm1
      CALL PUSHCONTROL1B(0)
    ELSE
      wqlijm1 = 1e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    IF (1e-6_sp .LT. qlij) THEN
      wqlij = qlij
      CALL PUSHCONTROL1B(0)
    ELSE
      wqlij = 1e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    IF (1e-6_sp .LT. qim1j) THEN
      wqim1j = qim1j
      CALL PUSHCONTROL1B(0)
    ELSE
      wqim1j = 1e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    IF (1e-6_sp .LT. qijm1) THEN
      wqijm1 = qijm1
      CALL PUSHCONTROL1B(0)
    ELSE
      wqijm1 = 1e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    dtddx = dt/dx
    d1 = dtddx
    pwx1 = (wqijm1+wqim1j)/2._sp
    pwy1 = bkw - 1._sp
    pwr1 = pwx1**pwy1
    d2 = akw*bkw*pwr1
    n1 = dtddx*wqim1j
    n2 = wqijm1*d2
    n3 = dtddx*(wqlijm1+wqlij)/2._sp
!% Linearized solution
    d2 = akw*bkw*pwr1
    pwy1 = bkw - 1._sp
    n2 = wqijm1*d2
    dtddx = dt/dx
    temp_b = qij_b/(d1+d2)
    n1_b = temp_b
    n2_b = temp_b
    n3_b = temp_b
    d2_b = wqijm1*n2_b - (n1+n2+n3)*temp_b/(d1+d2)
    temp_b = dtddx*n3_b/2._sp
    wqlijm1_b = temp_b
    wqlij_b = temp_b
    akw_b = akw_b + bkw*pwr1*d2_b
    pwr1_b = akw*bkw*d2_b
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwx1_b = 0.0_4
    ELSE
      pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
    END IF
    wqijm1_b = d2*n2_b + pwx1_b/2._sp
    wqim1j_b = dtddx*n1_b + pwx1_b/2._sp
    IF (pwx1 .LE. 0.0) THEN
      pwy1_b = 0.0_4
    ELSE
      pwy1_b = pwx1**pwy1*LOG(pwx1)*pwr1_b
    END IF
    bkw_b = bkw_b + akw*pwr1*d2_b + pwy1_b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qijm1_b = wqijm1_b
    ELSE
      qijm1_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qim1j_b = wqim1j_b
    ELSE
      qim1j_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qlij_b = wqlij_b
    ELSE
      qlij_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qlijm1_b = wqlijm1_b
    ELSE
      qlijm1_b = 0.0_4
    END IF
  END SUBROUTINE KINEMATIC_WAVE1D_B

  SUBROUTINE KINEMATIC_WAVE1D(dt, dx, akw, bkw, qlijm1, qlij, qim1j, &
&   qijm1, qij)
    IMPLICIT NONE
!% Non-Linear solution solved with Newton-Raphson
!% Commented while testing Linearized solution
!~         rhs = n1 + akw*wqijm1**bkw + n3
!~         iter = 0
!~         maxiter = 2
!~         rsd = 1._sp
!~         do while (abs(rsd) > 1e-6 .and. iter < maxiter)
!~             rsd = dtddx*qij + akw*qij**bkw - rhs
!~             rsd_d = dtddx + akw*bkw*qij**(bkw - 1._sp)
!~             qij = qij - rsd/rsd_d
!~             qij = max(qij, 0._sp)
!~             iter = iter + 1
!~         end do
    REAL(sp), INTENT(IN) :: dt, dx
    REAL(sp), INTENT(IN) :: akw, bkw
    REAL(sp), INTENT(IN) :: qlijm1, qlij, qim1j, qijm1
    REAL(sp), INTENT(INOUT) :: qij
    REAL(sp) :: wqlijm1, wqlij, wqim1j, wqijm1
    REAL(sp) :: dtddx, n1, n2, n3, d1, d2, rhs, rsd, rsd_d
    INTEGER :: iter, maxiter
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    IF (1e-6_sp .LT. qlijm1) THEN
      wqlijm1 = qlijm1
    ELSE
      wqlijm1 = 1e-6_sp
    END IF
    IF (1e-6_sp .LT. qlij) THEN
      wqlij = qlij
    ELSE
      wqlij = 1e-6_sp
    END IF
    IF (1e-6_sp .LT. qim1j) THEN
      wqim1j = qim1j
    ELSE
      wqim1j = 1e-6_sp
    END IF
    IF (1e-6_sp .LT. qijm1) THEN
      wqijm1 = qijm1
    ELSE
      wqijm1 = 1e-6_sp
    END IF
    dtddx = dt/dx
    d1 = dtddx
    pwx1 = (wqijm1+wqim1j)/2._sp
    pwy1 = bkw - 1._sp
    pwr1 = pwx1**pwy1
    d2 = akw*bkw*pwr1
    n1 = dtddx*wqim1j
    n2 = wqijm1*d2
    n3 = dtddx*(wqlijm1+wqlij)/2._sp
!% Linearized solution
    qij = (n1+n2+n3)/(d1+d2)
  END SUBROUTINE KINEMATIC_WAVE1D

END MODULE MD_ROUTING_OPERATOR_DIFF

!%      (MD) Module Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - gr4_lr_forward
!%      - gr4_kw_forward
!%      - grd_lr_forward
MODULE MD_FORWARD_STRUCTURE_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: sparse_matrix_to_matrix
  USE MWD_SPARSE_MATRIX_MANIPULATION
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, linear_routing, kinematic_wave1d
  USE MD_ROUTING_OPERATOR_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr4_lr_forward in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR4_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, output, output_d, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d, qt_d
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d&
&   , qd_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
    output_d%sim_response%q = 0.0_4
    q_d = 0.0_4
    qt_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION_D(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_d%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_d%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_d, ei, ei_d)
            en_d = -ei_d
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_d%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_d%opr_initial_states%values(row, &
&                          col, 2), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE_D(parameters%opr_parameters%values(row, col&
&                        , 4), parameters_d%opr_parameters%values(row, &
&                        col, 4), parameters%opr_initial_states%values(&
&                        row, col, 3), parameters_d%opr_initial_states%&
&                        values(row, col, 3), l, l_d)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr_d = 0.9_sp*(pr_d+perc_d) + l_d
          prr = 0.9_sp*(pr+perc) + l
          prd_d = 0.1_sp*(pr_d+perc_d)
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER_D(5._sp, prcp(row, col), prr, prr_d, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_d%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_d%opr_initial_states%values(row, col&
&                      , 3), qr, qr_d)
          IF (0._sp .LT. prd + l) THEN
            qd_d = prd_d + l_d
            qd = prd + l
          ELSE
            qd = 0._sp
            qd_d = 0.0_4
          END IF
          qt_d(row, col) = qr_d + qd_d
          qt(row, col) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt_d = mesh%dx*1e-3_sp*mesh%dy*qt_d/setup%dt
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 5), &
&                           parameters_d%opr_parameters%values(row, col&
&                           , 5), parameters%opr_initial_states%values(&
&                           row, col, 4), parameters_d%&
&                           opr_initial_states%values(row, col, 4), qup&
&                           , qup_d, qrout, qrout_d)
            q_d(row, col) = qrout_d + qt_d(row, col)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q_d(row, col) = qt_d(row, col)
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%sim_response%q(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR4_LR_FORWARD_D

!  Differentiation of gr4_lr_forward in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR4_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, output, output_b, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b, qt_b
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b&
&   , qd_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        prcp = input_data%atmos_data%prcp(:, :, t)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        pet = input_data%atmos_data%pet(:, :, t)
        CALL PUSHCONTROL1B(0)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL PUSHREAL4(pn)
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 1))
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            CALL PUSHREAL4(en)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 2))
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(parameters%opr_parameters%values(row, col, &
&                      4), parameters%opr_initial_states%values(row, col&
&                      , 3), l)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          CALL PUSHREAL4(prr)
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  3))
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
            CALL PUSHCONTROL1B(0)
          ELSE
            qd = 0._sp
            CALL PUSHCONTROL1B(1)
          END IF
          qt(row, col) = qr + qd
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(&
&           row, col)) THEN
!% [ END IF BC ]
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh%&
&                           dx(row, col), mesh%dy(row, col), mesh%flwacc&
&                           (row, col), mesh%flwdir, q, qup)
          CALL PUSHREAL4(qup)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  4))
          CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row, &
&                       col), mesh%flwacc(row, col), parameters%&
&                       opr_parameters%values(row, col, 5), parameters%&
&                       opr_initial_states%values(row, col, 4), qup, &
&                       qrout)
          q(row, col) = qrout + qt(row, col)
          CALL PUSHCONTROL2B(2)
        ELSE
          q(row, col) = qt(row, col)
          CALL PUSHCONTROL2B(1)
        END IF
      END DO
    END DO
    parameters_b%opr_parameters%values = 0.0_4
    parameters_b%opr_initial_states%values = 0.0_4
    q_b = 0.0_4
    qt_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%sim_response&
&         %q(g, t)
        output_b%sim_response%q(g, t) = 0.0_4
      END DO
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
          ELSE
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qrout_b = q_b(row, col)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 4))
            CALL POPREAL4(qup)
            CALL LINEAR_ROUTING_B(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 5), &
&                           parameters_b%opr_parameters%values(row, col&
&                           , 5), parameters%opr_initial_states%values(&
&                           row, col, 4), parameters_b%&
&                           opr_initial_states%values(row, col, 4), qup&
&                           , qup_b, qrout, qrout_b)
            CALL UPSTREAM_DISCHARGE_B(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_b, qup, qup_b)
          END IF
        END IF
      END DO
      qt_b = mesh%dx*1e-3_sp*mesh%dy*qt_b/setup%dt
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          qr_b = qt_b(row, col)
          qd_b = qt_b(row, col)
          qt_b(row, col) = 0.0_4
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(parameters%opr_initial_states%values(row, col, 3&
&                 ))
          CALL GR_TRANSFER_B(5._sp, prcp(row, col), prr, prr_b, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_b%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_b%opr_initial_states%values(row, col&
&                      , 3), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_EXCHANGE_B(parameters%opr_parameters%values(row, col&
&                        , 4), parameters_b%opr_parameters%values(row, &
&                        col, 4), parameters%opr_initial_states%values(&
&                        row, col, 3), parameters_b%opr_initial_states%&
&                        values(row, col, 3), l, l_b)
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 2))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_b%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_b%opr_initial_states%values(row, &
&                          col, 2), pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 1))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_b%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_b%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_b, ei, ei_b)
          END IF
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      ELSE
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      END IF
    END DO
  END SUBROUTINE GR4_LR_FORWARD_B

  SUBROUTINE GR4_LR_FORWARD(setup, mesh, input_data, parameters, output&
&   , options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(parameters%opr_parameters%values(row, col, &
&                      4), parameters%opr_initial_states%values(row, col&
&                      , 3), l)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh&
&                             %dx(row, col), mesh%dy(row, col), mesh%&
&                             flwacc(row, col), mesh%flwdir, q, qup)
            CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row&
&                         , col), mesh%flwacc(row, col), parameters%&
&                         opr_parameters%values(row, col, 5), parameters&
&                         %opr_initial_states%values(row, col, 4), qup, &
&                         qrout)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR4_LR_FORWARD

!  Differentiation of gr4_kw_forward in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR4_KW_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, output, output_d, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    INTEGER, PARAMETER :: zq=2
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt, q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt_d, q_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qlijm1, qlij&
&   , qijm1, qim1j, qij
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d&
&   , qd_d, qlijm1_d, qlij_d, qijm1_d, qim1j_d, qij_d
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
    q = 0._sp
    qt = 0._sp
    output_d%sim_response%q = 0.0_4
    q_d = 0.0_4
    qt_d = 0.0_4
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Swapping Q Buffer
!% =============================================================================================================== %!
      DO i=1,zq-1
        q_d(:, :, i) = q_d(:, :, i+1)
        q(:, :, i) = q(:, :, i+1)
        qt_d(:, :, i) = qt_d(:, :, i+1)
        qt(:, :, i) = qt(:, :, i+1)
      END DO
      q_d(:, :, zq) = 0.0_4
      q(:, :, zq) = 0._sp
      qt_d(:, :, zq) = 0.0_4
      qt(:, :, zq) = 0._sp
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION_D(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_d%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_d%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_d, ei, ei_d)
            en_d = -ei_d
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_d%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_d%opr_initial_states%values(row, &
&                          col, 2), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE_D(parameters%opr_parameters%values(row, col&
&                        , 4), parameters_d%opr_parameters%values(row, &
&                        col, 4), parameters%opr_initial_states%values(&
&                        row, col, 3), parameters_d%opr_initial_states%&
&                        values(row, col, 3), l, l_d)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr_d = 0.9_sp*(pr_d+perc_d) + l_d
          prr = 0.9_sp*(pr+perc) + l
          prd_d = 0.1_sp*(pr_d+perc_d)
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER_D(5._sp, prcp(row, col), prr, prr_d, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_d%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_d%opr_initial_states%values(row, col&
&                      , 3), qr, qr_d)
          IF (0._sp .LT. prd + l) THEN
            qd_d = prd_d + l_d
            qd = prd + l
          ELSE
            qd = 0._sp
            qd_d = 0.0_4
          END IF
          qt_d(row, col, zq) = qr_d + qd_d
          qt(row, col, zq) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt_d(:, :, zq) = mesh%dx*1e-3_sp*mesh%dy*qt_d(:, :, zq)/setup%dt
      qt(:, :, zq) = qt(:, :, zq)*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q(:&
&                               , :, zq), q_d(:, :, zq), qim1j, qim1j_d)
            qlijm1_d = qt_d(row, col, zq-1)
            qlijm1 = qt(row, col, zq-1)
            qlij_d = qt_d(row, col, zq)
            qlij = qt(row, col, zq)
            qijm1_d = q_d(row, col, zq-1)
            qijm1 = q(row, col, zq-1)
            CALL KINEMATIC_WAVE1D_D(setup%dt, mesh%dx(row, col), &
&                             parameters%opr_parameters%values(row, col&
&                             , 5), parameters_d%opr_parameters%values(&
&                             row, col, 5), parameters%opr_parameters%&
&                             values(row, col, 6), parameters_d%&
&                             opr_parameters%values(row, col, 6), qlijm1&
&                             , qlijm1_d, qlij, qlij_d, qim1j, qim1j_d, &
&                             qijm1, qijm1_d, qij, qij_d)
            q_d(row, col, zq) = qij_d
            q(row, col, zq) = qij
          ELSE
            q_d(row, col, zq) = qt_d(row, col, zq)
            q(row, col, zq) = qt(row, col, zq)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%sim_response%q(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2), zq)
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2), zq)
      END DO
    END DO
  END SUBROUTINE GR4_KW_FORWARD_D

!  Differentiation of gr4_kw_forward in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR4_KW_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, output, output_b, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    INTEGER, PARAMETER :: zq=2
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt, q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt_b, q_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qlijm1, qlij&
&   , qijm1, qim1j, qij
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b&
&   , qd_b, qlijm1_b, qlij_b, qijm1_b, qim1j_b, qij_b
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
    q = 0._sp
    qt = 0._sp
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Swapping Q Buffer
!% =============================================================================================================== %!
      DO i=1,zq-1
        q(:, :, i) = q(:, :, i+1)
        qt(:, :, i) = qt(:, :, i+1)
      END DO
      q(:, :, zq) = 0._sp
      qt(:, :, zq) = 0._sp
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        prcp = input_data%atmos_data%prcp(:, :, t)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        pet = input_data%atmos_data%pet(:, :, t)
        CALL PUSHCONTROL1B(0)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL PUSHREAL4(pn)
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 1))
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            CALL PUSHREAL4(en)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 2))
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(parameters%opr_parameters%values(row, col, &
&                      4), parameters%opr_initial_states%values(row, col&
&                      , 3), l)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          CALL PUSHREAL4(prr)
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  3))
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
            CALL PUSHCONTROL1B(0)
          ELSE
            qd = 0._sp
            CALL PUSHCONTROL1B(1)
          END IF
          qt(row, col, zq) = qr + qd
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!~             !$OMP end parallel do
      qt(:, :, zq) = qt(:, :, zq)*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(&
&           row, col)) THEN
!% [ END IF BC ]
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL PUSHREAL4(qim1j)
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh%&
&                           dx(row, col), mesh%dy(row, col), mesh%flwacc&
&                           (row, col), mesh%flwdir, q(:, :, zq), qim1j)
          CALL PUSHREAL4(qlijm1)
          qlijm1 = qt(row, col, zq-1)
          CALL PUSHREAL4(qlij)
          qlij = qt(row, col, zq)
          CALL PUSHREAL4(qijm1)
          qijm1 = q(row, col, zq-1)
          CALL KINEMATIC_WAVE1D(setup%dt, mesh%dx(row, col), parameters%&
&                         opr_parameters%values(row, col, 5), parameters&
&                         %opr_parameters%values(row, col, 6), qlijm1, &
&                         qlij, qim1j, qijm1, qij)
          q(row, col, zq) = qij
          CALL PUSHCONTROL2B(2)
        ELSE
          q(row, col, zq) = qt(row, col, zq)
          CALL PUSHCONTROL2B(1)
        END IF
      END DO
    END DO
    parameters_b%opr_parameters%values = 0.0_4
    parameters_b%opr_initial_states%values = 0.0_4
    q_b = 0.0_4
    qt_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2), zq) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2), zq) + output_b%&
&         sim_response%q(g, t)
        output_b%sim_response%q(g, t) = 0.0_4
      END DO
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qt_b(row, col, zq) = qt_b(row, col, zq) + q_b(row, col, zq)
            q_b(row, col, zq) = 0.0_4
          ELSE
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qij_b = q_b(row, col, zq)
            q_b(row, col, zq) = 0.0_4
            CALL KINEMATIC_WAVE1D_B(setup%dt, mesh%dx(row, col), &
&                             parameters%opr_parameters%values(row, col&
&                             , 5), parameters_b%opr_parameters%values(&
&                             row, col, 5), parameters%opr_parameters%&
&                             values(row, col, 6), parameters_b%&
&                             opr_parameters%values(row, col, 6), qlijm1&
&                             , qlijm1_b, qlij, qlij_b, qim1j, qim1j_b, &
&                             qijm1, qijm1_b, qij, qij_b)
            CALL POPREAL4(qijm1)
            q_b(row, col, zq-1) = q_b(row, col, zq-1) + qijm1_b
            CALL POPREAL4(qlij)
            qt_b(row, col, zq) = qt_b(row, col, zq) + qlij_b
            CALL POPREAL4(qlijm1)
            qt_b(row, col, zq-1) = qt_b(row, col, zq-1) + qlijm1_b
            CALL POPREAL4(qim1j)
            CALL UPSTREAM_DISCHARGE_B(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q(:&
&                               , :, zq), q_b(:, :, zq), qim1j, qim1j_b)
          END IF
        END IF
      END DO
      qt_b(:, :, zq) = mesh%dx*1e-3_sp*mesh%dy*qt_b(:, :, zq)/setup%dt
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          qr_b = qt_b(row, col, zq)
          qd_b = qt_b(row, col, zq)
          qt_b(row, col, zq) = 0.0_4
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(parameters%opr_initial_states%values(row, col, 3&
&                 ))
          CALL GR_TRANSFER_B(5._sp, prcp(row, col), prr, prr_b, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_b%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_b%opr_initial_states%values(row, col&
&                      , 3), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_EXCHANGE_B(parameters%opr_parameters%values(row, col&
&                        , 4), parameters_b%opr_parameters%values(row, &
&                        col, 4), parameters%opr_initial_states%values(&
&                        row, col, 3), parameters_b%opr_initial_states%&
&                        values(row, col, 3), l, l_b)
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 2))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_b%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_b%opr_initial_states%values(row, &
&                          col, 2), pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 1))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_b%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_b%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_b, ei, ei_b)
          END IF
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      ELSE
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      END IF
      qt_b(:, :, zq) = 0.0_4
      q_b(:, :, zq) = 0.0_4
      DO i=zq-1,1,-1
        qt_b(:, :, i+1) = qt_b(:, :, i+1) + qt_b(:, :, i)
        qt_b(:, :, i) = 0.0_4
        q_b(:, :, i+1) = q_b(:, :, i+1) + q_b(:, :, i)
        q_b(:, :, i) = 0.0_4
      END DO
    END DO
  END SUBROUTINE GR4_KW_FORWARD_B

  SUBROUTINE GR4_KW_FORWARD(setup, mesh, input_data, parameters, output&
&   , options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    INTEGER, PARAMETER :: zq=2
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt, q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qlijm1, qlij&
&   , qijm1, qim1j, qij
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
    q = 0._sp
    qt = 0._sp
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Swapping Q Buffer
!% =============================================================================================================== %!
      DO i=1,zq-1
        q(:, :, i) = q(:, :, i+1)
        qt(:, :, i) = qt(:, :, i+1)
      END DO
      q(:, :, zq) = 0._sp
      qt(:, :, zq) = 0._sp
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(parameters%opr_parameters%values(row, col, &
&                      4), parameters%opr_initial_states%values(row, col&
&                      , 3), l)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col, zq) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt(:, :, zq) = qt(:, :, zq)*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh&
&                             %dx(row, col), mesh%dy(row, col), mesh%&
&                             flwacc(row, col), mesh%flwdir, q(:, :, zq)&
&                             , qim1j)
            qlijm1 = qt(row, col, zq-1)
            qlij = qt(row, col, zq)
            qijm1 = q(row, col, zq-1)
            CALL KINEMATIC_WAVE1D(setup%dt, mesh%dx(row, col), &
&                           parameters%opr_parameters%values(row, col, 5&
&                           ), parameters%opr_parameters%values(row, col&
&                           , 6), qlijm1, qlij, qim1j, qijm1, qij)
            q(row, col, zq) = qij
          ELSE
            q(row, col, zq) = qt(row, col, zq)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2), zq)
      END DO
    END DO
  END SUBROUTINE GR4_KW_FORWARD

!  Differentiation of gr5_lr_forward in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR5_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, output, output_d, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d, qt_d
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d&
&   , qd_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
    output_d%sim_response%q = 0.0_4
    q_d = 0.0_4
    qt_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION_D(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_d%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_d%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_d, ei, ei_d)
            en_d = -ei_d
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_d%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_d%opr_initial_states%values(row, &
&                          col, 2), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_THRESHOLD_EXCHANGE_D(parameters%opr_parameters%&
&                                  values(row, col, 4), parameters_d%&
&                                  opr_parameters%values(row, col, 4), &
&                                  parameters%opr_initial_states%values(&
&                                  row, col, 3), parameters_d%&
&                                  opr_initial_states%values(row, col, 3&
&                                  ), parameters%opr_parameters%values(&
&                                  row, col, 5), parameters_d%&
&                                  opr_parameters%values(row, col, 5), l&
&                                  , l_d)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr_d = 0.9_sp*(pr_d+perc_d) + l_d
          prr = 0.9_sp*(pr+perc) + l
          prd_d = 0.1_sp*(pr_d+perc_d)
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER_D(5._sp, prcp(row, col), prr, prr_d, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_d%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_d%opr_initial_states%values(row, col&
&                      , 3), qr, qr_d)
          IF (0._sp .LT. prd + l) THEN
            qd_d = prd_d + l_d
            qd = prd + l
          ELSE
            qd = 0._sp
            qd_d = 0.0_4
          END IF
          qt_d(row, col) = qr_d + qd_d
          qt(row, col) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt_d = mesh%dx*1e-3_sp*mesh%dy*qt_d/setup%dt
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 6), &
&                           parameters_d%opr_parameters%values(row, col&
&                           , 6), parameters%opr_initial_states%values(&
&                           row, col, 4), parameters_d%&
&                           opr_initial_states%values(row, col, 4), qup&
&                           , qup_d, qrout, qrout_d)
            q_d(row, col) = qrout_d + qt_d(row, col)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q_d(row, col) = qt_d(row, col)
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%sim_response%q(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR5_LR_FORWARD_D

!  Differentiation of gr5_lr_forward in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR5_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, output, output_b, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b, qt_b
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b&
&   , qd_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        prcp = input_data%atmos_data%prcp(:, :, t)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        pet = input_data%atmos_data%pet(:, :, t)
        CALL PUSHCONTROL1B(0)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL PUSHREAL4(pn)
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 1))
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            CALL PUSHREAL4(en)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 2))
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_THRESHOLD_EXCHANGE(parameters%opr_parameters%values(&
&                                row, col, 4), parameters%&
&                                opr_initial_states%values(row, col, 3)&
&                                , parameters%opr_parameters%values(row&
&                                , col, 5), l)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          CALL PUSHREAL4(prr)
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  3))
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
            CALL PUSHCONTROL1B(0)
          ELSE
            qd = 0._sp
            CALL PUSHCONTROL1B(1)
          END IF
          qt(row, col) = qr + qd
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(&
&           row, col)) THEN
!% [ END IF BC ]
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh%&
&                           dx(row, col), mesh%dy(row, col), mesh%flwacc&
&                           (row, col), mesh%flwdir, q, qup)
          CALL PUSHREAL4(qup)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  4))
          CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row, &
&                       col), mesh%flwacc(row, col), parameters%&
&                       opr_parameters%values(row, col, 6), parameters%&
&                       opr_initial_states%values(row, col, 4), qup, &
&                       qrout)
          q(row, col) = qrout + qt(row, col)
          CALL PUSHCONTROL2B(2)
        ELSE
          q(row, col) = qt(row, col)
          CALL PUSHCONTROL2B(1)
        END IF
      END DO
    END DO
    parameters_b%opr_parameters%values = 0.0_4
    parameters_b%opr_initial_states%values = 0.0_4
    q_b = 0.0_4
    qt_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%sim_response&
&         %q(g, t)
        output_b%sim_response%q(g, t) = 0.0_4
      END DO
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
          ELSE
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qrout_b = q_b(row, col)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 4))
            CALL POPREAL4(qup)
            CALL LINEAR_ROUTING_B(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 6), &
&                           parameters_b%opr_parameters%values(row, col&
&                           , 6), parameters%opr_initial_states%values(&
&                           row, col, 4), parameters_b%&
&                           opr_initial_states%values(row, col, 4), qup&
&                           , qup_b, qrout, qrout_b)
            CALL UPSTREAM_DISCHARGE_B(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_b, qup, qup_b)
          END IF
        END IF
      END DO
      qt_b = mesh%dx*1e-3_sp*mesh%dy*qt_b/setup%dt
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          qr_b = qt_b(row, col)
          qd_b = qt_b(row, col)
          qt_b(row, col) = 0.0_4
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(parameters%opr_initial_states%values(row, col, 3&
&                 ))
          CALL GR_TRANSFER_B(5._sp, prcp(row, col), prr, prr_b, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_b%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_b%opr_initial_states%values(row, col&
&                      , 3), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_THRESHOLD_EXCHANGE_B(parameters%opr_parameters%&
&                                  values(row, col, 4), parameters_b%&
&                                  opr_parameters%values(row, col, 4), &
&                                  parameters%opr_initial_states%values(&
&                                  row, col, 3), parameters_b%&
&                                  opr_initial_states%values(row, col, 3&
&                                  ), parameters%opr_parameters%values(&
&                                  row, col, 5), parameters_b%&
&                                  opr_parameters%values(row, col, 5), l&
&                                  , l_b)
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 2))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_b%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_b%opr_initial_states%values(row, &
&                          col, 2), pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 1))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_b%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_b%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_b, ei, ei_b)
          END IF
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      ELSE
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      END IF
    END DO
  END SUBROUTINE GR5_LR_FORWARD_B

  SUBROUTINE GR5_LR_FORWARD(setup, mesh, input_data, parameters, output&
&   , options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_THRESHOLD_EXCHANGE(parameters%opr_parameters%values(&
&                                row, col, 4), parameters%&
&                                opr_initial_states%values(row, col, 3)&
&                                , parameters%opr_parameters%values(row&
&                                , col, 5), l)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh&
&                             %dx(row, col), mesh%dy(row, col), mesh%&
&                             flwacc(row, col), mesh%flwdir, q, qup)
            CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row&
&                         , col), mesh%flwacc(row, col), parameters%&
&                         opr_parameters%values(row, col, 6), parameters&
&                         %opr_initial_states%values(row, col, 4), qup, &
&                         qrout)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR5_LR_FORWARD

!  Differentiation of gr5_kw_forward in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR5_KW_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, output, output_d, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    INTEGER, PARAMETER :: zq=2
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt, q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt_d, q_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qlijm1, qlij&
&   , qijm1, qim1j, qij
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d&
&   , qd_d, qlijm1_d, qlij_d, qijm1_d, qim1j_d, qij_d
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
    q = 0._sp
    qt = 0._sp
    output_d%sim_response%q = 0.0_4
    q_d = 0.0_4
    qt_d = 0.0_4
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Swapping Q Buffer
!% =============================================================================================================== %!
      DO i=1,zq-1
        q_d(:, :, i) = q_d(:, :, i+1)
        q(:, :, i) = q(:, :, i+1)
        qt_d(:, :, i) = qt_d(:, :, i+1)
        qt(:, :, i) = qt(:, :, i+1)
      END DO
      q_d(:, :, zq) = 0.0_4
      q(:, :, zq) = 0._sp
      qt_d(:, :, zq) = 0.0_4
      qt(:, :, zq) = 0._sp
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION_D(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_d%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_d%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_d, ei, ei_d)
            en_d = -ei_d
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_d%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_d%opr_initial_states%values(row, &
&                          col, 2), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_THRESHOLD_EXCHANGE_D(parameters%opr_parameters%&
&                                  values(row, col, 4), parameters_d%&
&                                  opr_parameters%values(row, col, 4), &
&                                  parameters%opr_initial_states%values(&
&                                  row, col, 3), parameters_d%&
&                                  opr_initial_states%values(row, col, 3&
&                                  ), parameters%opr_parameters%values(&
&                                  row, col, 5), parameters_d%&
&                                  opr_parameters%values(row, col, 5), l&
&                                  , l_d)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr_d = 0.9_sp*(pr_d+perc_d) + l_d
          prr = 0.9_sp*(pr+perc) + l
          prd_d = 0.1_sp*(pr_d+perc_d)
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER_D(5._sp, prcp(row, col), prr, prr_d, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_d%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_d%opr_initial_states%values(row, col&
&                      , 3), qr, qr_d)
          IF (0._sp .LT. prd + l) THEN
            qd_d = prd_d + l_d
            qd = prd + l
          ELSE
            qd = 0._sp
            qd_d = 0.0_4
          END IF
          qt_d(row, col, zq) = qr_d + qd_d
          qt(row, col, zq) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt_d(:, :, zq) = mesh%dx*1e-3_sp*mesh%dy*qt_d(:, :, zq)/setup%dt
      qt(:, :, zq) = qt(:, :, zq)*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q(:&
&                               , :, zq), q_d(:, :, zq), qim1j, qim1j_d)
            qlijm1_d = qt_d(row, col, zq-1)
            qlijm1 = qt(row, col, zq-1)
            qlij_d = qt_d(row, col, zq)
            qlij = qt(row, col, zq)
            qijm1_d = q_d(row, col, zq-1)
            qijm1 = q(row, col, zq-1)
            CALL KINEMATIC_WAVE1D_D(setup%dt, mesh%dx(row, col), &
&                             parameters%opr_parameters%values(row, col&
&                             , 6), parameters_d%opr_parameters%values(&
&                             row, col, 6), parameters%opr_parameters%&
&                             values(row, col, 7), parameters_d%&
&                             opr_parameters%values(row, col, 7), qlijm1&
&                             , qlijm1_d, qlij, qlij_d, qim1j, qim1j_d, &
&                             qijm1, qijm1_d, qij, qij_d)
            q_d(row, col, zq) = qij_d
            q(row, col, zq) = qij
          ELSE
            q_d(row, col, zq) = qt_d(row, col, zq)
            q(row, col, zq) = qt(row, col, zq)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%sim_response%q(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2), zq)
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2), zq)
      END DO
    END DO
  END SUBROUTINE GR5_KW_FORWARD_D

!  Differentiation of gr5_kw_forward in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GR5_KW_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, output, output_b, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    INTEGER, PARAMETER :: zq=2
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt, q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt_b, q_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qlijm1, qlij&
&   , qijm1, qim1j, qij
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b&
&   , qd_b, qlijm1_b, qlij_b, qijm1_b, qim1j_b, qij_b
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
    q = 0._sp
    qt = 0._sp
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Swapping Q Buffer
!% =============================================================================================================== %!
      DO i=1,zq-1
        q(:, :, i) = q(:, :, i+1)
        qt(:, :, i) = qt(:, :, i+1)
      END DO
      q(:, :, zq) = 0._sp
      qt(:, :, zq) = 0._sp
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        prcp = input_data%atmos_data%prcp(:, :, t)
        CALL PUSHREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        pet = input_data%atmos_data%pet(:, :, t)
        CALL PUSHCONTROL1B(0)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL PUSHREAL4(pn)
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 1))
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            CALL PUSHREAL4(en)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 2))
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_THRESHOLD_EXCHANGE(parameters%opr_parameters%values(&
&                                row, col, 4), parameters%&
&                                opr_initial_states%values(row, col, 3)&
&                                , parameters%opr_parameters%values(row&
&                                , col, 5), l)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          CALL PUSHREAL4(prr)
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  3))
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
            CALL PUSHCONTROL1B(0)
          ELSE
            qd = 0._sp
            CALL PUSHCONTROL1B(1)
          END IF
          qt(row, col, zq) = qr + qd
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!~             !$OMP end parallel do
      qt(:, :, zq) = qt(:, :, zq)*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(&
&           row, col)) THEN
!% [ END IF BC ]
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL PUSHREAL4(qim1j)
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh%&
&                           dx(row, col), mesh%dy(row, col), mesh%flwacc&
&                           (row, col), mesh%flwdir, q(:, :, zq), qim1j)
          CALL PUSHREAL4(qlijm1)
          qlijm1 = qt(row, col, zq-1)
          CALL PUSHREAL4(qlij)
          qlij = qt(row, col, zq)
          CALL PUSHREAL4(qijm1)
          qijm1 = q(row, col, zq-1)
          CALL KINEMATIC_WAVE1D(setup%dt, mesh%dx(row, col), parameters%&
&                         opr_parameters%values(row, col, 6), parameters&
&                         %opr_parameters%values(row, col, 7), qlijm1, &
&                         qlij, qim1j, qijm1, qij)
          q(row, col, zq) = qij
          CALL PUSHCONTROL2B(2)
        ELSE
          q(row, col, zq) = qt(row, col, zq)
          CALL PUSHCONTROL2B(1)
        END IF
      END DO
    END DO
    parameters_b%opr_parameters%values = 0.0_4
    parameters_b%opr_initial_states%values = 0.0_4
    q_b = 0.0_4
    qt_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2), zq) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2), zq) + output_b%&
&         sim_response%q(g, t)
        output_b%sim_response%q(g, t) = 0.0_4
      END DO
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qt_b(row, col, zq) = qt_b(row, col, zq) + q_b(row, col, zq)
            q_b(row, col, zq) = 0.0_4
          ELSE
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qij_b = q_b(row, col, zq)
            q_b(row, col, zq) = 0.0_4
            CALL KINEMATIC_WAVE1D_B(setup%dt, mesh%dx(row, col), &
&                             parameters%opr_parameters%values(row, col&
&                             , 6), parameters_b%opr_parameters%values(&
&                             row, col, 6), parameters%opr_parameters%&
&                             values(row, col, 7), parameters_b%&
&                             opr_parameters%values(row, col, 7), qlijm1&
&                             , qlijm1_b, qlij, qlij_b, qim1j, qim1j_b, &
&                             qijm1, qijm1_b, qij, qij_b)
            CALL POPREAL4(qijm1)
            q_b(row, col, zq-1) = q_b(row, col, zq-1) + qijm1_b
            CALL POPREAL4(qlij)
            qt_b(row, col, zq) = qt_b(row, col, zq) + qlij_b
            CALL POPREAL4(qlijm1)
            qt_b(row, col, zq-1) = qt_b(row, col, zq-1) + qlijm1_b
            CALL POPREAL4(qim1j)
            CALL UPSTREAM_DISCHARGE_B(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q(:&
&                               , :, zq), q_b(:, :, zq), qim1j, qim1j_b)
          END IF
        END IF
      END DO
      qt_b(:, :, zq) = mesh%dx*1e-3_sp*mesh%dy*qt_b(:, :, zq)/setup%dt
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          qr_b = qt_b(row, col, zq)
          qd_b = qt_b(row, col, zq)
          qt_b(row, col, zq) = 0.0_4
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(parameters%opr_initial_states%values(row, col, 3&
&                 ))
          CALL GR_TRANSFER_B(5._sp, prcp(row, col), prr, prr_b, &
&                      parameters%opr_parameters%values(row, col, 3), &
&                      parameters_b%opr_parameters%values(row, col, 3), &
&                      parameters%opr_initial_states%values(row, col, 3)&
&                      , parameters_b%opr_initial_states%values(row, col&
&                      , 3), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_THRESHOLD_EXCHANGE_B(parameters%opr_parameters%&
&                                  values(row, col, 4), parameters_b%&
&                                  opr_parameters%values(row, col, 4), &
&                                  parameters%opr_initial_states%values(&
&                                  row, col, 3), parameters_b%&
&                                  opr_initial_states%values(row, col, 3&
&                                  ), parameters%opr_parameters%values(&
&                                  row, col, 5), parameters_b%&
&                                  opr_parameters%values(row, col, 5), l&
&                                  , l_b)
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 2))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%&
&                          opr_parameters%values(row, col, 2), &
&                          parameters_b%opr_parameters%values(row, col, &
&                          2), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 2), &
&                          parameters_b%opr_initial_states%values(row, &
&                          col, 2), pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 1))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp(row, col), pet(row, col), &
&                            parameters%opr_parameters%values(row, col, &
&                            1), parameters_b%opr_parameters%values(row&
&                            , col, 1), parameters%opr_initial_states%&
&                            values(row, col, 1), parameters_b%&
&                            opr_initial_states%values(row, col, 1), pn&
&                            , pn_b, ei, ei_b)
          END IF
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      ELSE
        CALL POPREAL4ARRAY(pet, mesh%nrow*mesh%ncol)
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      END IF
      qt_b(:, :, zq) = 0.0_4
      q_b(:, :, zq) = 0.0_4
      DO i=zq-1,1,-1
        qt_b(:, :, i+1) = qt_b(:, :, i+1) + qt_b(:, :, i)
        qt_b(:, :, i) = 0.0_4
        q_b(:, :, i+1) = q_b(:, :, i+1) + q_b(:, :, i)
        q_b(:, :, i) = 0.0_4
      END DO
    END DO
  END SUBROUTINE GR5_KW_FORWARD_B

  SUBROUTINE GR5_KW_FORWARD(setup, mesh, input_data, parameters, output&
&   , options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    INTEGER, PARAMETER :: zq=2
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, zq) :: qt, q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qlijm1, qlij&
&   , qijm1, qim1j, qij
    INTEGER :: t, i, row, col, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
    q = 0._sp
    qt = 0._sp
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Swapping Q Buffer
!% =============================================================================================================== %!
      DO i=1,zq-1
        q(:, :, i) = q(:, :, i+1)
        qt(:, :, i) = qt(:, :, i+1)
      END DO
      q(:, :, zq) = 0._sp
      qt(:, :, zq) = 0._sp
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION(prcp(row, col), pet(row, col), &
&                          parameters%opr_parameters%values(row, col, 1)&
&                          , parameters%opr_initial_states%values(row, &
&                          col, 1), pn, ei)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 2), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 2), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_THRESHOLD_EXCHANGE(parameters%opr_parameters%values(&
&                                row, col, 4), parameters%&
&                                opr_initial_states%values(row, col, 3)&
&                                , parameters%opr_parameters%values(row&
&                                , col, 5), l)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 3), parameters%&
&                    opr_initial_states%values(row, col, 3), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col, zq) = qr + qd
        END IF
      END DO
!~             !$OMP end parallel do
      qt(:, :, zq) = qt(:, :, zq)*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh&
&                             %dx(row, col), mesh%dy(row, col), mesh%&
&                             flwacc(row, col), mesh%flwdir, q(:, :, zq)&
&                             , qim1j)
            qlijm1 = qt(row, col, zq-1)
            qlij = qt(row, col, zq)
            qijm1 = q(row, col, zq-1)
            CALL KINEMATIC_WAVE1D(setup%dt, mesh%dx(row, col), &
&                           parameters%opr_parameters%values(row, col, 6&
&                           ), parameters%opr_parameters%values(row, col&
&                           , 7), qlijm1, qlij, qim1j, qijm1, qij)
            q(row, col, zq) = qij
          ELSE
            q(row, col, zq) = qt(row, col, zq)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2), zq)
      END DO
    END DO
  END SUBROUTINE GR5_KW_FORWARD

!  Differentiation of loieau_lr_forward in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE LOIEAU_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, output, output_d, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d, qt_d
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    REAL(sp) :: pn_d, en_d, pr_d, perc_d, prr_d, prd_d, qr_d, qd_d, &
&   qup_d, qrout_d
    INTEGER :: t, i, row, col, g
    INTRINSIC MIN
    INTRINSIC MAX
    output_d%sim_response%q = 0.0_4
    q_d = 0.0_4
    qt_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
            IF (pet(row, col) .GT. prcp(row, col)) THEN
              ei = prcp(row, col)
            ELSE
              ei = pet(row, col)
            END IF
            IF (0._sp .LT. prcp(row, col) - ei) THEN
              pn = prcp(row, col) - ei
            ELSE
              pn = 0._sp
            END IF
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            en_d = 0.0_4
            pn_d = 0.0_4
            CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%&
&                          opr_parameters%values(row, col, 1), &
&                          parameters_d%opr_parameters%values(row, col, &
&                          1), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 1), &
&                          parameters_d%opr_initial_states%values(row, &
&                          col, 1), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
!call gr_exchange(parameters%opr_parameters%values(row, col, 4), &
!& parameters%opr_initial_states%values(row, col, 3), l)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr_d = 0.9_sp*(pr_d+perc_d)
          prr = 0.9_sp*(pr+perc) + l
          prd_d = 0.1_sp*(pr_d+perc_d)
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER_D(4._sp, prcp(row, col), prr, prr_d, &
&                      parameters%opr_parameters%values(row, col, 2), &
&                      parameters_d%opr_parameters%values(row, col, 2), &
&                      parameters%opr_initial_states%values(row, col, 2)&
&                      , parameters_d%opr_initial_states%values(row, col&
&                      , 2), qr, qr_d)
          IF (0._sp .LT. prd + l) THEN
            qd_d = prd_d
            qd = prd + l
          ELSE
            qd = 0._sp
            qd_d = 0.0_4
          END IF
          qt_d(row, col) = (qr+qd)*parameters_d%opr_parameters%values(&
&           row, col, 3) + parameters%opr_parameters%values(row, col, 3)&
&           *(qr_d+qd_d)
          qt(row, col) = parameters%opr_parameters%values(row, col, 3)*(&
&           qr+qd)
        END IF
      END DO
!~             !$OMP end parallel do
      qt_d = mesh%dx*1e-3_sp*mesh%dy*qt_d/setup%dt
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 4), &
&                           parameters_d%opr_parameters%values(row, col&
&                           , 4), parameters%opr_initial_states%values(&
&                           row, col, 3), parameters_d%&
&                           opr_initial_states%values(row, col, 3), qup&
&                           , qup_d, qrout, qrout_d)
            q_d(row, col) = qrout_d + qt_d(row, col)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q_d(row, col) = qt_d(row, col)
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%sim_response%q(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE LOIEAU_LR_FORWARD_D

!  Differentiation of loieau_lr_forward in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE LOIEAU_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, output, output_b, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b, qt_b
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    REAL(sp) :: pn_b, en_b, pr_b, perc_b, prr_b, prd_b, qr_b, qd_b, &
&   qup_b, qrout_b
    INTEGER :: t, i, row, col, g
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp_b
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
        CALL PUSHCONTROL1B(0)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
            IF (pet(row, col) .GT. prcp(row, col)) THEN
              ei = prcp(row, col)
            ELSE
              ei = pet(row, col)
            END IF
            IF (0._sp .LT. prcp(row, col) - ei) THEN
              CALL PUSHREAL4(pn)
              pn = prcp(row, col) - ei
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(pn)
              pn = 0._sp
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL4(en)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 1))
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 1), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 1), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
!call gr_exchange(parameters%opr_parameters%values(row, col, 4), &
!& parameters%opr_initial_states%values(row, col, 3), l)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          CALL PUSHREAL4(prr)
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL PUSHREAL4(qr)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  2))
          CALL GR_TRANSFER(4._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 2), parameters%&
&                    opr_initial_states%values(row, col, 2), qr)
          IF (0._sp .LT. prd + l) THEN
            CALL PUSHREAL4(qd)
            qd = prd + l
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL4(qd)
            qd = 0._sp
            CALL PUSHCONTROL1B(1)
          END IF
          qt(row, col) = parameters%opr_parameters%values(row, col, 3)*(&
&           qr+qd)
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(&
&           row, col)) THEN
!% [ END IF BC ]
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh%&
&                           dx(row, col), mesh%dy(row, col), mesh%flwacc&
&                           (row, col), mesh%flwdir, q, qup)
          CALL PUSHREAL4(qup)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  3))
          CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row, &
&                       col), mesh%flwacc(row, col), parameters%&
&                       opr_parameters%values(row, col, 4), parameters%&
&                       opr_initial_states%values(row, col, 3), qup, &
&                       qrout)
          q(row, col) = qrout + qt(row, col)
          CALL PUSHCONTROL2B(2)
        ELSE
          q(row, col) = qt(row, col)
          CALL PUSHCONTROL2B(1)
        END IF
      END DO
    END DO
    parameters_b%opr_parameters%values = 0.0_4
    parameters_b%opr_initial_states%values = 0.0_4
    q_b = 0.0_4
    qt_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%sim_response&
&         %q(g, t)
        output_b%sim_response%q(g, t) = 0.0_4
      END DO
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
          ELSE
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qrout_b = q_b(row, col)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 3))
            CALL POPREAL4(qup)
            CALL LINEAR_ROUTING_B(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 4), &
&                           parameters_b%opr_parameters%values(row, col&
&                           , 4), parameters%opr_initial_states%values(&
&                           row, col, 3), parameters_b%&
&                           opr_initial_states%values(row, col, 3), qup&
&                           , qup_b, qrout, qrout_b)
            CALL UPSTREAM_DISCHARGE_B(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_b, qup, qup_b)
          END IF
        END IF
      END DO
      qt_b = mesh%dx*1e-3_sp*mesh%dy*qt_b/setup%dt
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          parameters_b%opr_parameters%values(row, col, 3) = parameters_b&
&           %opr_parameters%values(row, col, 3) + (qr+qd)*qt_b(row, col)
          temp_b = parameters%opr_parameters%values(row, col, 3)*qt_b(&
&           row, col)
          qt_b(row, col) = 0.0_4
          qr_b = temp_b
          qd_b = temp_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(qd)
            prd_b = qd_b
          ELSE
            CALL POPREAL4(qd)
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(parameters%opr_initial_states%values(row, col, 2&
&                 ))
          CALL POPREAL4(qr)
          CALL GR_TRANSFER_B(4._sp, prcp(row, col), prr, prr_b, &
&                      parameters%opr_parameters%values(row, col, 2), &
&                      parameters_b%opr_parameters%values(row, col, 2), &
&                      parameters%opr_initial_states%values(row, col, 2)&
&                      , parameters_b%opr_initial_states%values(row, col&
&                      , 2), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 1))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%&
&                          opr_parameters%values(row, col, 1), &
&                          parameters_b%opr_parameters%values(row, col, &
&                          1), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 1), &
&                          parameters_b%opr_initial_states%values(row, &
&                          col, 1), pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(pn)
            ELSE
              CALL POPREAL4(pn)
            END IF
          END IF
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      ELSE
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      END IF
    END DO
  END SUBROUTINE LOIEAU_LR_FORWARD_B

  SUBROUTINE LOIEAU_LR_FORWARD(setup, mesh, input_data, parameters, &
&   output, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp) :: ei, pn, en, pr, perc, l, prr, prd, qr, qd, qup, qrout
    INTEGER :: t, i, row, col, g
    INTRINSIC MIN
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, l, prr, prd, qr, qd)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
            IF (pet(row, col) .GT. prcp(row, col)) THEN
              ei = prcp(row, col)
            ELSE
              ei = pet(row, col)
            END IF
            IF (0._sp .LT. prcp(row, col) - ei) THEN
              pn = prcp(row, col) - ei
            ELSE
              pn = 0._sp
            END IF
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 1), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 1), pr, &
&                        perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
!call gr_exchange(parameters%opr_parameters%values(row, col, 4), &
!& parameters%opr_initial_states%values(row, col, 3), l)
          ELSE
            pr = 0._sp
            perc = 0._sp
            l = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(4._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 2), parameters%&
&                    opr_initial_states%values(row, col, 2), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col) = parameters%opr_parameters%values(row, col, 3)*(&
&           qr+qd)
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh&
&                             %dx(row, col), mesh%dy(row, col), mesh%&
&                             flwacc(row, col), mesh%flwdir, q, qup)
            CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row&
&                         , col), mesh%flwacc(row, col), parameters%&
&                         opr_parameters%values(row, col, 4), parameters&
&                         %opr_initial_states%values(row, col, 3), qup, &
&                         qrout)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE LOIEAU_LR_FORWARD

!  Differentiation of grd_lr_forward in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GRD_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, output, output_d, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d, qt_d
    REAL(sp) :: ei, pn, en, pr, perc, prr, qr, qup, qrout
    REAL(sp) :: pn_d, en_d, pr_d, perc_d, prr_d, qr_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, g
    INTRINSIC MIN
    INTRINSIC MAX
    output_d%sim_response%q = 0.0_4
    q_d = 0.0_4
    qt_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, prr, qr)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
            IF (pet(row, col) .GT. prcp(row, col)) THEN
              ei = prcp(row, col)
            ELSE
              ei = pet(row, col)
            END IF
            IF (0._sp .LT. prcp(row, col) - ei) THEN
              pn = prcp(row, col) - ei
            ELSE
              pn = 0._sp
            END IF
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            en_d = 0.0_4
            pn_d = 0.0_4
            CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%&
&                          opr_parameters%values(row, col, 1), &
&                          parameters_d%opr_parameters%values(row, col, &
&                          1), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 1), &
&                          parameters_d%opr_initial_states%values(row, &
&                          col, 1), pr, pr_d, perc, perc_d)
          ELSE
            pr = 0._sp
            perc = 0._sp
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr_d = pr_d + perc_d
          prr = pr + perc
          CALL GR_TRANSFER_D(5._sp, prcp(row, col), prr, prr_d, &
&                      parameters%opr_parameters%values(row, col, 2), &
&                      parameters_d%opr_parameters%values(row, col, 2), &
&                      parameters%opr_initial_states%values(row, col, 2)&
&                      , parameters_d%opr_initial_states%values(row, col&
&                      , 2), qr, qr_d)
          qt_d(row, col) = qr_d
          qt(row, col) = qr
        END IF
      END DO
!~             !$OMP end parallel do
      qt_d = mesh%dx*1e-3_sp*mesh%dy*qt_d/setup%dt
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 3), &
&                           parameters_d%opr_parameters%values(row, col&
&                           , 3), parameters%opr_initial_states%values(&
&                           row, col, 3), parameters_d%&
&                           opr_initial_states%values(row, col, 3), qup&
&                           , qup_d, qrout, qrout_d)
            q_d(row, col) = qrout_d + qt_d(row, col)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q_d(row, col) = qt_d(row, col)
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%sim_response%q(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GRD_LR_FORWARD_D

!  Differentiation of grd_lr_forward in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: *(output.sim_response.q)
!   with respect to varying inputs: *(parameters.opr_parameters.values)
!                *(parameters.opr_initial_states.values)
!   Plus diff mem management of: parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
  SUBROUTINE GRD_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, output, output_b, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b, qt_b
    REAL(sp) :: ei, pn, en, pr, perc, prr, qr, qup, qrout
    REAL(sp) :: pn_b, en_b, pr_b, perc_b, prr_b, qr_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
        CALL PUSHCONTROL1B(0)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, prr, qr)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
            IF (pet(row, col) .GT. prcp(row, col)) THEN
              ei = prcp(row, col)
            ELSE
              ei = pet(row, col)
            END IF
            IF (0._sp .LT. prcp(row, col) - ei) THEN
              CALL PUSHREAL4(pn)
              pn = prcp(row, col) - ei
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(pn)
              pn = 0._sp
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL4(en)
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL PUSHREAL4(parameters%opr_initial_states%values(row, col&
&                    , 1))
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 1), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 1), pr, &
&                        perc)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
            pr = 0._sp
            perc = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          CALL PUSHREAL4(prr)
          prr = pr + perc
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  2))
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 2), parameters%&
&                    opr_initial_states%values(row, col, 2), qr)
          qt(row, col) = qr
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(&
&           row, col)) THEN
!% [ END IF BC ]
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh%&
&                           dx(row, col), mesh%dy(row, col), mesh%flwacc&
&                           (row, col), mesh%flwdir, q, qup)
          CALL PUSHREAL4(qup)
          CALL PUSHREAL4(parameters%opr_initial_states%values(row, col, &
&                  3))
          CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row, &
&                       col), mesh%flwacc(row, col), parameters%&
&                       opr_parameters%values(row, col, 3), parameters%&
&                       opr_initial_states%values(row, col, 3), qup, &
&                       qrout)
          q(row, col) = qrout + qt(row, col)
          CALL PUSHCONTROL2B(2)
        ELSE
          q(row, col) = qt(row, col)
          CALL PUSHCONTROL2B(1)
        END IF
      END DO
    END DO
    parameters_b%opr_parameters%values = 0.0_4
    parameters_b%opr_initial_states%values = 0.0_4
    q_b = 0.0_4
    qt_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%sim_response&
&         %q(g, t)
        output_b%sim_response%q(g, t) = 0.0_4
      END DO
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
          ELSE
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            qrout_b = q_b(row, col)
            qt_b(row, col) = qt_b(row, col) + q_b(row, col)
            q_b(row, col) = 0.0_4
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 3))
            CALL POPREAL4(qup)
            CALL LINEAR_ROUTING_B(setup%dt, mesh%dx(row, col), mesh%dy(&
&                           row, col), mesh%flwacc(row, col), parameters&
&                           %opr_parameters%values(row, col, 3), &
&                           parameters_b%opr_parameters%values(row, col&
&                           , 3), parameters%opr_initial_states%values(&
&                           row, col, 3), parameters_b%&
&                           opr_initial_states%values(row, col, 3), qup&
&                           , qup_b, qrout, qrout_b)
            CALL UPSTREAM_DISCHARGE_B(mesh%nrow, mesh%ncol, row, col, &
&                               mesh%dx(row, col), mesh%dy(row, col), &
&                               mesh%flwacc(row, col), mesh%flwdir, q, &
&                               q_b, qup, qup_b)
          END IF
        END IF
      END DO
      qt_b = mesh%dx*1e-3_sp*mesh%dy*qt_b/setup%dt
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          qr_b = qt_b(row, col)
          qt_b(row, col) = 0.0_4
          CALL POPREAL4(parameters%opr_initial_states%values(row, col, 2&
&                 ))
          CALL GR_TRANSFER_B(5._sp, prcp(row, col), prr, prr_b, &
&                      parameters%opr_parameters%values(row, col, 2), &
&                      parameters_b%opr_parameters%values(row, col, 2), &
&                      parameters%opr_initial_states%values(row, col, 2)&
&                      , parameters_b%opr_initial_states%values(row, col&
&                      , 2), qr, qr_b)
          CALL POPREAL4(prr)
          pr_b = prr_b
          perc_b = prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(parameters%opr_initial_states%values(row, col&
&                   , 1))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%&
&                          opr_parameters%values(row, col, 1), &
&                          parameters_b%opr_parameters%values(row, col, &
&                          1), 9._sp/4._sp, parameters%&
&                          opr_initial_states%values(row, col, 1), &
&                          parameters_b%opr_initial_states%values(row, &
&                          col, 1), pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(pn)
            ELSE
              CALL POPREAL4(pn)
            END IF
          END IF
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      ELSE
        CALL POPREAL4ARRAY(prcp, mesh%nrow*mesh%ncol)
      END IF
    END DO
  END SUBROUTINE GRD_LR_FORWARD_B

  SUBROUTINE GRD_LR_FORWARD(setup, mesh, input_data, parameters, output&
&   , options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: prcp, pet, q, qt
    REAL(sp) :: ei, pn, en, pr, perc, prr, qr, qup, qrout
    INTEGER :: t, i, row, col, g
    INTRINSIC MIN
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% =============================================================================================================== %!
!%  Getting Precipitation and PET at time step
!% =============================================================================================================== %!
      IF (setup%sparse_storage) THEN
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_prcp(t), prcp)
        CALL SPARSE_MATRIX_TO_MATRIX(mesh, input_data%atmos_data%&
&                              sparse_pet(t), pet)
      ELSE
        prcp = input_data%atmos_data%prcp(:, :, t)
        pet = input_data%atmos_data%pet(:, :, t)
      END IF
!~             !$OMP parallel do schedule(static) num_threads(options%comm%ncpu) &
!~             !$OMP& shared(setup, mesh, input_data, parameters, output, options, returns, prcp, pet, qt) &
!~             !$OMP& private(i, row, col, ei, pn, en, pr, perc, prr, qr)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF PRCP GAP ]
          IF (prcp(row, col) .GE. 0._sp .AND. pet(row, col) .GE. 0._sp) &
&         THEN
            IF (pet(row, col) .GT. prcp(row, col)) THEN
              ei = prcp(row, col)
            ELSE
              ei = pet(row, col)
            END IF
            IF (0._sp .LT. prcp(row, col) - ei) THEN
              pn = prcp(row, col) - ei
            ELSE
              pn = 0._sp
            END IF
            en = pet(row, col) - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, parameters%opr_parameters%values(&
&                        row, col, 1), 9._sp/4._sp, parameters%&
&                        opr_initial_states%values(row, col, 1), pr, &
&                        perc)
          ELSE
            pr = 0._sp
            perc = 0._sp
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = pr + perc
          CALL GR_TRANSFER(5._sp, prcp(row, col), prr, parameters%&
&                    opr_parameters%values(row, col, 2), parameters%&
&                    opr_initial_states%values(row, col, 2), qr)
          qt(row, col) = qr
        END IF
      END DO
!~             !$OMP end parallel do
      qt = qt*1e-3_sp*mesh%dx*mesh%dy/setup%dt
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% [ END IF BC ]
          IF (mesh%flwacc(row, col) .GT. mesh%dx(row, col)*mesh%dy(row, &
&             col)) THEN
!% [ IF BC ]
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, row, col, mesh&
&                             %dx(row, col), mesh%dy(row, col), mesh%&
&                             flwacc(row, col), mesh%flwdir, q, qup)
            CALL LINEAR_ROUTING(setup%dt, mesh%dx(row, col), mesh%dy(row&
&                         , col), mesh%flwacc(row, col), parameters%&
&                         opr_parameters%values(row, col, 3), parameters&
&                         %opr_initial_states%values(row, col, 3), qup, &
&                         qrout)
            q(row, col) = qrout + qt(row, col)
          ELSE
            q(row, col) = qt(row, col)
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GRD_LR_FORWARD

END MODULE MD_FORWARD_STRUCTURE_DIFF

!  Differentiation of base_forward_run in forward (tangent) mode (with options fixinterface noISIZE OpenMP context):
!   variations   of useful results: output.cost
!   with respect to varying inputs: *(parameters.control.x)
!   RW status of diff variables: parameters.control.x:(loc) *(parameters.control.x):in-killed
!                *(parameters.opr_parameters.values):(loc) *(parameters.opr_initial_states.values):(loc)
!                *(output.sim_response.q):(loc) output.cost:out
!   Plus diff mem management of: parameters.control.x:in parameters.control.l:in
!                parameters.control.u:in parameters.control.l_bkg:in
!                parameters.control.u_bkg:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
SUBROUTINE BASE_FORWARD_RUN_D(setup, mesh, input_data, parameters, &
& parameters_d, output, output_d, options, returns)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: control_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: gr4_lr_forward, gr4_kw_forward, gr5_lr_forward, gr5_kw_forward, grd_lr_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT), INTENT(INOUT) :: output_d
  TYPE(OPTIONSDT), INTENT(IN) :: options
  TYPE(RETURNSDT), INTENT(INOUT) :: returns
  REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nos) :: &
& opr_states_buffer_values
!% Map control to parameters
  CALL CONTROL_TO_PARAMETERS_D(setup, mesh, input_data, parameters, &
&                        parameters_d, options)
!% Save initial states
!% Simulation
  SELECT CASE  (setup%structure) 
  CASE ('gr4-lr') 
    CALL GR4_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&                   parameters_d, output, output_d, options, returns)
  CASE ('gr4-kw') 
    CALL GR4_KW_FORWARD_D(setup, mesh, input_data, parameters, &
&                   parameters_d, output, output_d, options, returns)
  CASE ('gr5-lr') 
    CALL GR5_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&                   parameters_d, output, output_d, options, returns)
  CASE ('gr5-kw') 
    CALL GR5_KW_FORWARD_D(setup, mesh, input_data, parameters, &
&                   parameters_d, output, output_d, options, returns)
  CASE ('loieau-lr') 
    CALL LOIEAU_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&                      parameters_d, output, output_d, options, returns)
  CASE ('grd-lr') 
    CALL GRD_LR_FORWARD_D(setup, mesh, input_data, parameters, &
&                   parameters_d, output, output_d, options, returns)
  CASE DEFAULT
    output_d%sim_response%q = 0.0_4
  END SELECT
!% Assign final states and reset initial states
  parameters_d%opr_initial_states%values = 0.0_4
!% Compute cost
  CALL COMPUTE_COST_D(setup, mesh, input_data, parameters, output, &
&               output_d, options, returns)
END SUBROUTINE BASE_FORWARD_RUN_D

!  Differentiation of base_forward_run in reverse (adjoint) mode (with options fixinterface noISIZE OpenMP context):
!   gradient     of useful results: output.cost
!   with respect to varying inputs: *(parameters.control.x)
!   RW status of diff variables: parameters.control.x:(loc) *(parameters.control.x):out
!                *(parameters.opr_parameters.values):(loc) *(parameters.opr_initial_states.values):(loc)
!                *(output.sim_response.q):(loc) output.cost:in-killed
!   Plus diff mem management of: parameters.control.x:in parameters.control.l:in
!                parameters.control.u:in parameters.control.l_bkg:in
!                parameters.control.u_bkg:in parameters.opr_parameters.values:in
!                parameters.opr_initial_states.values:in output.sim_response.q:in
SUBROUTINE BASE_FORWARD_RUN_B(setup, mesh, input_data, parameters, &
& parameters_b, output, output_b, options, returns)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: control_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: gr4_lr_forward, gr4_kw_forward, gr5_lr_forward, gr5_kw_forward, grd_lr_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT), INTENT(INOUT) :: output_b
  TYPE(OPTIONSDT), INTENT(IN) :: options
  TYPE(RETURNSDT), INTENT(INOUT) :: returns
  REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nos) :: &
& opr_states_buffer_values
  INTEGER :: branch
!% Map control to parameters
  CALL PUSHREAL4ARRAY(parameters%control%x, SIZE(parameters%control%x, 1&
&               ))
  CALL CONTROL_TO_PARAMETERS(setup, mesh, input_data, parameters, &
&                      options)
!% Save initial states
!% Simulation
  SELECT CASE  (setup%structure) 
  CASE ('gr4-lr') 
    CALL PUSHREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                 parameters%opr_initial_states%values, 1)*SIZE(&
&                 parameters%opr_initial_states%values, 2)*SIZE(&
&                 parameters%opr_initial_states%values, 3))
    CALL GR4_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
    CALL PUSHCONTROL3B(1)
  CASE ('gr4-kw') 
    CALL PUSHREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                 parameters%opr_initial_states%values, 1)*SIZE(&
&                 parameters%opr_initial_states%values, 2)*SIZE(&
&                 parameters%opr_initial_states%values, 3))
    CALL GR4_KW_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
    CALL PUSHCONTROL3B(2)
  CASE ('gr5-lr') 
    CALL PUSHREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                 parameters%opr_initial_states%values, 1)*SIZE(&
&                 parameters%opr_initial_states%values, 2)*SIZE(&
&                 parameters%opr_initial_states%values, 3))
    CALL GR5_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
    CALL PUSHCONTROL3B(3)
  CASE ('gr5-kw') 
    CALL PUSHREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                 parameters%opr_initial_states%values, 1)*SIZE(&
&                 parameters%opr_initial_states%values, 2)*SIZE(&
&                 parameters%opr_initial_states%values, 3))
    CALL GR5_KW_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
    CALL PUSHCONTROL3B(4)
  CASE ('loieau-lr') 
    CALL PUSHREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                 parameters%opr_initial_states%values, 1)*SIZE(&
&                 parameters%opr_initial_states%values, 2)*SIZE(&
&                 parameters%opr_initial_states%values, 3))
    CALL LOIEAU_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                    options, returns)
    CALL PUSHCONTROL3B(5)
  CASE ('grd-lr') 
    CALL PUSHREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                 parameters%opr_initial_states%values, 1)*SIZE(&
&                 parameters%opr_initial_states%values, 2)*SIZE(&
&                 parameters%opr_initial_states%values, 3))
    CALL GRD_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
    CALL PUSHCONTROL3B(6)
  CASE DEFAULT
    CALL PUSHCONTROL3B(0)
  END SELECT
!% Assign final states and reset initial states
!% Compute cost
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, output, options&
&             , returns)
  CALL COMPUTE_COST_B(setup, mesh, input_data, parameters, output, &
&               output_b, options, returns)
  CALL POPCONTROL3B(branch)
  IF (branch .LT. 3) THEN
    IF (branch .EQ. 0) THEN
      parameters_b%opr_parameters%values = 0.0_4
      parameters_b%opr_initial_states%values = 0.0_4
    ELSE IF (branch .EQ. 1) THEN
      CALL POPREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                  parameters%opr_initial_states%values, 1)*SIZE(&
&                  parameters%opr_initial_states%values, 2)*SIZE(&
&                  parameters%opr_initial_states%values, 3))
      CALL GR4_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&                     parameters_b, output, output_b, options, returns)
    ELSE
      CALL POPREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                  parameters%opr_initial_states%values, 1)*SIZE(&
&                  parameters%opr_initial_states%values, 2)*SIZE(&
&                  parameters%opr_initial_states%values, 3))
      CALL GR4_KW_FORWARD_B(setup, mesh, input_data, parameters, &
&                     parameters_b, output, output_b, options, returns)
    END IF
  ELSE IF (branch .LT. 5) THEN
    IF (branch .EQ. 3) THEN
      CALL POPREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                  parameters%opr_initial_states%values, 1)*SIZE(&
&                  parameters%opr_initial_states%values, 2)*SIZE(&
&                  parameters%opr_initial_states%values, 3))
      CALL GR5_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&                     parameters_b, output, output_b, options, returns)
    ELSE
      CALL POPREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                  parameters%opr_initial_states%values, 1)*SIZE(&
&                  parameters%opr_initial_states%values, 2)*SIZE(&
&                  parameters%opr_initial_states%values, 3))
      CALL GR5_KW_FORWARD_B(setup, mesh, input_data, parameters, &
&                     parameters_b, output, output_b, options, returns)
    END IF
  ELSE IF (branch .EQ. 5) THEN
    CALL POPREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                parameters%opr_initial_states%values, 1)*SIZE(&
&                parameters%opr_initial_states%values, 2)*SIZE(&
&                parameters%opr_initial_states%values, 3))
    CALL LOIEAU_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&                      parameters_b, output, output_b, options, returns)
  ELSE
    CALL POPREAL4ARRAY(parameters%opr_initial_states%values, SIZE(&
&                parameters%opr_initial_states%values, 1)*SIZE(&
&                parameters%opr_initial_states%values, 2)*SIZE(&
&                parameters%opr_initial_states%values, 3))
    CALL GRD_LR_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, output, output_b, options, returns)
  END IF
  CALL POPREAL4ARRAY(parameters%control%x, SIZE(parameters%control%x, 1)&
&             )
  CALL CONTROL_TO_PARAMETERS_B(setup, mesh, input_data, parameters, &
&                        parameters_b, options)
END SUBROUTINE BASE_FORWARD_RUN_B

SUBROUTINE BASE_FORWARD_RUN_NODIFF(setup, mesh, input_data, parameters, &
& output, options, returns)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: control_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: gr4_lr_forward, gr4_kw_forward, gr5_lr_forward, gr5_kw_forward, grd_lr_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OPTIONSDT), INTENT(IN) :: options
  TYPE(RETURNSDT), INTENT(INOUT) :: returns
  REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nos) :: &
& opr_states_buffer_values
!% Map control to parameters
  CALL CONTROL_TO_PARAMETERS(setup, mesh, input_data, parameters, &
&                      options)
!% Save initial states
  opr_states_buffer_values = parameters%opr_initial_states%values
!% Simulation
  SELECT CASE  (setup%structure) 
  CASE ('gr4-lr') 
    CALL GR4_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
  CASE ('gr4-kw') 
    CALL GR4_KW_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
  CASE ('gr5-lr') 
    CALL GR5_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
  CASE ('gr5-kw') 
    CALL GR5_KW_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
  CASE ('loieau-lr') 
    CALL LOIEAU_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                    options, returns)
  CASE ('grd-lr') 
    CALL GRD_LR_FORWARD(setup, mesh, input_data, parameters, output, &
&                 options, returns)
  END SELECT
!% Assign final states and reset initial states
  output%opr_final_states%values = parameters%opr_initial_states%values
  parameters%opr_initial_states%values = opr_states_buffer_values
!% Compute cost
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, output, options&
&             , returns)
END SUBROUTINE BASE_FORWARD_RUN_NODIFF

