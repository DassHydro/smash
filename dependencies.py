from __future__ import annotations

import pathlib
import re

FILE_KEYS = ["c", "f77", "f90"]
BUILD_DIR = "obj"
SPACE4 = " " * 4


def find_module_dep_impl_statement(f: pathlib.Path) -> tuple[set[str], set[str]]:
    """
    Function that find Fortran use and module statement with regex

    Parameters
    ----------
    f : pathlib.Path
        The file to parse as a pathlib.Path object

    Returns
    -------
    res : tuple
        A tuple containing a set of module dependencies and implementations in the file **f**

    Notes
    -----
    An explanation of the pattern: r"^(?!\\s*[!]).*?use\\s+(\\w+)"

    - ^ : Matches the start of a line
    - (?!\\s*[!]) : Negative lookahead that excludes matches with ! after zero or more whitespace characters
      (\\s)
    - .*? : Lazy match of any character (.) zero or more times (*) until it encounters the next part of the
      pattern
    - use\\s+ : Matches the string "use" followed by one or more whitespace characters (\\s)
    - (\\w+) : Captures one or more word characters (\\w+) after "use" as a group

    So this regex pattern looks for lines that start with "use" followed by one or more whitespace
    characters, but excludes lines that have a comment symbol (!) before the "use".
    It then captures the module name that follows "use".

    It's the same regex pattern with "module".
    """

    content = open(f, "r").read()
    dep_pattern = r"^(?!\s*[!]).*?use\s+(\w+)"
    impl_pattern = r"^(?!\s*[!]).*?module\s+(\w+)"

    dep = {
        el.lower()
        for el in re.findall(
            dep_pattern,
            content,
            flags=re.IGNORECASE | re.MULTILINE,
        )
    }

    impl = {
        el.lower()
        for el in re.findall(
            impl_pattern,
            content,
            flags=re.IGNORECASE | re.MULTILINE,
        )
        if el.lower() not in ["procedure"]
    }

    return dep, impl


def get_module_dependencies(
    files: list[pathlib.Path],
) -> tuple[dict[pathlib.Path, set[str]], dict[str, pathlib.Path]]:
    """
    Function that find module dependencies and implementations for each file

    Parameters
    ----------
    files : list
        The list of file to parse as a pathlib.Path object

    Returns
    -------
    res : tuple
        A tuple containing a dictionary of module dependencies and a dictionary of module implementations
    """

    file_mod_dep = {}
    mod_file_impl = {}

    for f in files:
        mod_dep, mod_impl = find_module_dep_impl_statement(f)
        file_mod_dep.update({f: mod_dep})
        for m in mod_impl:
            mod_file_impl.update({m: f})

    return file_mod_dep, mod_file_impl


def generate_fortran_dependencies(files: list[pathlib.Path]) -> dict[str, set[str]]:
    """
    Function that find Fortran file dependencies for each file

    Parameters
    ----------
    files : list
        The list of file to parse as a pathlib.Path object

    Returns
    -------
    res : dict
        The dictionary of dependencies. The keys are the name of each
        file and the associated values are the set of each file dependencies
    """

    file_mod_dep, mod_file_impl = get_module_dependencies(files)

    deps = {}

    for key, value in file_mod_dep.items():
        deps[key] = {mod_file_impl[v] for v in value if mod_file_impl[v] != key}

    return deps


if __name__ == "__main__":
    fcore_path = pathlib.Path("smash/fcore/")
    c_files = sorted(fcore_path.glob("*/*.c"))
    f77_files = sorted(fcore_path.glob("*/*.f"))
    f90_files = sorted(set(fcore_path.glob("*/*.f90")) - set(fcore_path.glob("f90wrap/*.f90")))

    files = dict(zip(FILE_KEYS, [c_files, f77_files, f90_files]))

    # % No C files dependencies
    c_deps = {f: set() for f in c_files}
    # % No F77 files dependencies
    f77_deps = {f: set() for f in f77_files}
    # % F90 files dependencies
    f90_deps = generate_fortran_dependencies(f90_files)

    deps = dict(zip(FILE_KEYS, [c_deps, f77_deps, f90_deps]))

    with open("makefile.dep", "w") as dep_file:
        dep_file.write("#% This file is automatically generated by dependencies.py" + 2 * "\n")

        # % Main Targets
        for key in FILE_KEYS:
            dep_file.write(f"{key} : \\\n")
            for f in files[key]:
                dep_file.write(f"{SPACE4}{BUILD_DIR}/{f.stem}.o \\\n")
            dep_file.write("\n")

        # % Dependencies Targets
        for key in FILE_KEYS:
            for f in files[key]:
                dep_file.write(f"{BUILD_DIR}/{f.stem}.o : \\\n")
                for d in deps[key][f]:
                    dep_file.write(f"{SPACE4}{BUILD_DIR}/{d.stem}.o \\\n")
                dep_file.write("\n")
